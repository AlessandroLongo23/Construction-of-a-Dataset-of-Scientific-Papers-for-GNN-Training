{
    "key": "doc",
    "block_type": "document",
    "children": [
        {
            "leaf id": 0,
            "key": "doc/tit",
            "block type": "title",
            "content": "How to use and interpret activation patching",
            "leftover": "",
            "matches": [
                {
                    "pdf_id": "0.33",
                    "matching_string": "How to use and interpret activation patching"
                }
            ]
        },
        {
            "leaf id": 1,
            "key": "doc/aut0",
            "block type": "author",
            "content": "{ Stefan Heimersheim stefan.heimersheim@gmail.com \\And Neel Nanda }",
            "leftover": "{ \\And }",
            "matches": [
                {
                    "pdf_id": "0.34",
                    "matching_string": "stefan.heimersheim@gmail.com "
                },
                {
                    "pdf_id": "0.36",
                    "matching_string": "Neel Nanda "
                },
                {
                    "pdf_id": "0.35",
                    "matching_string": "Stefan Heimersheim "
                }
            ]
        },
        {
            "leaf id": 2,
            "key": "doc/abs",
            "block type": "abstract",
            "content": "Activation patching is a popular mechanistic interpretability technique, but has many subtleties regarding how it is applied and how one may interpret the results. We provide a summary of advice and best practices, based on our experience using this technique in practice. We include an overview of the different ways to apply activation patching and a discussion on how to interpret the results. We focus on what evidence patching experiments provide about circuits, and on the choice of metric and associated pitfalls.",
            "leftover": "",
            "matches": [
                {
                    "pdf_id": "0.37",
                    "matching_string": "Activation patching is a popular mechanistic interpretability technique, but has "
                },
                {
                    "pdf_id": "0.39",
                    "matching_string": "We provide a summary of advice and best practices, based on our experience using "
                },
                {
                    "pdf_id": "0.40",
                    "matching_string": "this technique in practice. We include an overview of the different ways to apply "
                },
                {
                    "pdf_id": "0.41",
                    "matching_string": "activation patching and a discussion on how to interpret the results. We focus on "
                },
                {
                    "pdf_id": "0.42",
                    "matching_string": "what evidence patching experiments provide about circuits, and on the choice of "
                },
                {
                    "pdf_id": "0.43",
                    "matching_string": "metric and associated pitfalls."
                },
                {
                    "pdf_id": "0.38",
                    "matching_string": "many subtleties regarding how it is applied and how one may interpret the results. "
                }
            ]
        },
        {
            "key": "doc/body",
            "block_type": "body",
            "children": [
                {
                    "key": "doc/body/sec0",
                    "block_type": "sec",
                    "children": [
                        {
                            "leaf id": 3,
                            "key": "doc/body/sec0/tit",
                            "block type": "title",
                            "content": "Introduction",
                            "leftover": "",
                            "matches": [
                                {
                                    "pdf_id": "0.45",
                                    "matching_string": "Introduction"
                                }
                            ]
                        },
                        {
                            "key": "doc/body/sec0/sub0",
                            "block_type": "sub",
                            "children": [
                                {
                                    "leaf id": 4,
                                    "key": "doc/body/sec0/sub0/tit",
                                    "block type": "title",
                                    "content": "What is activation patching?",
                                    "leftover": "",
                                    "matches": [
                                        {
                                            "pdf_id": "0.46",
                                            "matching_string": "What is activation patching?"
                                        }
                                    ]
                                },
                                {
                                    "leaf id": 5,
                                    "key": "doc/body/sec0/sub0/txl0",
                                    "block type": "txl",
                                    "content": "Activation patching (also referred to as Interchange Intervention, Causal Tracing, Resample Ablation, or Causal Mediation Analysis) is the technique of replacing internal activations of a neural net. It is also known as Causal Tracing, Resample Ablation, Interchange Intervention or more generally as Causal Mediation Analysis. Variants of this technique have been widely used in the literature \\citep{2020arXiv200412265V,2021arXiv210602997G,2020arXiv200414623G,2019arXiv191009113S,2021arXiv210606087F,2021arXiv211200826G,ROME,IOI,causalscrubbing,2023arXiv230104213H,2023arXiv230500586H,ACDC,2023arXiv231015213T,2023arXiv231015916H,2023arXiv231017191F,LieberumChincilla,2023arXiv230908600C,2023arXiv230515054S,NixPathPatching,CallumCopySuppression,2023arXiv230414767G,2023arXiv230910312H,2023arXiv231008744M,2023arXiv231015154T,}. Here we focus on the technique where we overwrite some activations during a model run with cached activations from a previous run (on a different input), and observe how this affects the model's output.",
                                    "leftover": "",
                                    "matches": [
                                        {
                                            "pdf_id": "0.48",
                                            "matching_string": "or Causal Mediation Analysis) is the technique of replacing internal activations of a neural net. It is "
                                        },
                                        {
                                            "pdf_id": "0.49",
                                            "matching_string": "also known as Causal Tracing, Resample Ablation, Interchange Intervention or more generally as "
                                        },
                                        {
                                            "pdf_id": "0.57",
                                            "matching_string": "technique where we overwrite some activations during a model run with cached activations from a "
                                        },
                                        {
                                            "pdf_id": "0.58",
                                            "matching_string": "previous run (on a different input), and observe how this affects the model's output."
                                        },
                                        {
                                            "pdf_id": "0.47",
                                            "matching_string": "Activation patching (also referred to as Interchange Intervention, Causal Tracing, Resample Ablation, "
                                        },
                                        {
                                            "pdf_id": "0.50",
                                            "matching_string": "Causal Mediation Analysis. Variants of this technique have been widely used in the literature "
                                        },
                                        {
                                            "pdf_id": "0.51",
                                            "matching_string": "\\citep{2020arXiv200412265V,2021arXiv210602997G,2020arXiv200414623G,2019arXiv191009113S,2021arXiv210606087F,2021arXiv211200826G,ROME,IOI,causalscrubbing,2023arXiv230104213H,2023arXiv230500586H,ACDC,2023arXiv231015213T,2023arXiv231015916H,2023arXiv231017191F,LieberumChincilla,2023arXiv230908600C,2023arXiv230515054S,NixPathPatching,CallumCopySuppression,2023arXiv230414767G,2023arXiv230910312H,2023arXiv231008744M,2023arXiv231015154T,}. Here we focus on the "
                                        },
                                        {
                                            "pdf_id": "0.52",
                                            "matching_string": ""
                                        },
                                        {
                                            "pdf_id": "0.53",
                                            "matching_string": ""
                                        },
                                        {
                                            "pdf_id": "0.54",
                                            "matching_string": ""
                                        },
                                        {
                                            "pdf_id": "0.55",
                                            "matching_string": ""
                                        },
                                        {
                                            "pdf_id": "0.56",
                                            "matching_string": ""
                                        }
                                    ]
                                }
                            ]
                        },
                        {
                            "key": "doc/body/sec0/sub1",
                            "block_type": "sub",
                            "children": [
                                {
                                    "leaf id": 6,
                                    "key": "doc/body/sec0/sub1/tit",
                                    "block type": "title",
                                    "content": "How is this related to ablation?",
                                    "leftover": "",
                                    "matches": [
                                        {
                                            "pdf_id": "0.59",
                                            "matching_string": "How is this related to ablation?"
                                        }
                                    ]
                                },
                                {
                                    "leaf id": 7,
                                    "key": "doc/body/sec0/sub1/txl0",
                                    "block type": "txl",
                                    "content": "Ablation is the common technique of zeroing out activations. Activation patching is more targeted and controlled: We replace activations with other activations rather than zeroing them out. This allows us to make targeted manipulations to locate specific model behaviours and circuits.",
                                    "leftover": "",
                                    "matches": [
                                        {
                                            "pdf_id": "0.61",
                                            "matching_string": "and controlled: We replace activations with other activations rather than zeroing them out. This "
                                        },
                                        {
                                            "pdf_id": "0.62",
                                            "matching_string": "allows us to make targeted manipulations to locate specific model behaviours and circuits."
                                        },
                                        {
                                            "pdf_id": "0.60",
                                            "matching_string": "Ablation is the common technique of zeroing out activations. Activation patching is more targeted "
                                        }
                                    ]
                                }
                            ]
                        },
                        {
                            "key": "doc/body/sec0/sub2",
                            "block_type": "sub",
                            "children": [
                                {
                                    "leaf id": 8,
                                    "key": "doc/body/sec0/sub2/tit",
                                    "block type": "title",
                                    "content": "An example",
                                    "leftover": "",
                                    "matches": [
                                        {
                                            "pdf_id": "0.63",
                                            "matching_string": "An example"
                                        }
                                    ]
                                },
                                {
                                    "key": "doc/body/sec0/sub2/txl0",
                                    "block_type": "txl",
                                    "children": [
                                        {
                                            "leaf id": 9,
                                            "key": "doc/body/sec0/sub2/txl0/txl0",
                                            "block type": "txl",
                                            "content": "For example, let's say we want to know which model internals are responsible for factual recall in ROME \\citepROME. How does the model complete the prompt “The Colosseum is in” with the answer “Rome”? To answer this question we want to manipulate the model's activations. But the model activations contain many bits of information: This is an English sentence; The landmark in question is the Colosseum; This is a factual statement about a location.",
                                            "leftover": "",
                                            "matches": [
                                                {
                                                    "pdf_id": "0.64",
                                                    "matching_string": "For example, let's say we want to know which model internals are responsible for factual recall in "
                                                },
                                                {
                                                    "pdf_id": "0.67",
                                                    "matching_string": "model activations contain many bits of information: This is an English sentence; The landmark in "
                                                },
                                                {
                                                    "pdf_id": "0.68",
                                                    "matching_string": "question is the Colosseum; This is a factual statement about a location."
                                                },
                                                {
                                                    "pdf_id": "0.13",
                                                    "matching_string": "s "
                                                },
                                                {
                                                    "pdf_id": "0.66",
                                                    "matching_string": "the answer “Rome”? To answer this question we want to manipulate the model'activations. But the "
                                                },
                                                {
                                                    "pdf_id": "0.65",
                                                    "matching_string": "ROME \\citepROME. How does the model complete the prompt “The Colosseum is in” with "
                                                }
                                            ]
                                        }
                                    ]
                                },
                                {
                                    "key": "doc/body/sec0/sub2/txl1",
                                    "block_type": "txl",
                                    "children": [
                                        {
                                            "leaf id": 10,
                                            "key": "doc/body/sec0/sub2/txl1/txl0",
                                            "block type": "txl",
                                            "content": "Ablating some activations will affect the model if these activations are relevant for any of these bits. But activation patching allows us to choose which bit to change and control for the others. Patching with activations from “Il Colosseo è dentro” locates where the model stores the language of the prompt but may use the same factual recall machinery. Patching with activations from “The Louvre is in” locates which part of the model deals with the landmark and information recall. Patching between “The Colosseum is in the city of” and “The Colosseum is in the country of” locates the part of the model that determines which attributes of an entity are recalled.",
                                            "leftover": "in” “",
                                            "matches": [
                                                {
                                                    "pdf_id": "0.69",
                                                    "matching_string": "Ablating some activations will affect the model if these activations are relevant for any of these bits. "
                                                },
                                                {
                                                    "pdf_id": "1.1",
                                                    "matching_string": "model that determines which attributes of an entity are recalled."
                                                },
                                                {
                                                    "pdf_id": "0.71",
                                                    "matching_string": "with activations from “Il Colosseo è dentro” locates where the model stores the language of the "
                                                },
                                                {
                                                    "pdf_id": "0.72",
                                                    "matching_string": "prompt but may use the same factual recall machinery. Patching with activations from “The Louvre is "
                                                },
                                                {
                                                    "pdf_id": "0.73",
                                                    "matching_string": "locates which part of the model deals with the landmark and information recall. Patching between "
                                                },
                                                {
                                                    "pdf_id": "0.70",
                                                    "matching_string": "But activation patching allows us to choose which bit to change and control for the others. Patching "
                                                },
                                                {
                                                    "pdf_id": "1.0",
                                                    "matching_string": "The Colosseum is in the city of” and “The Colosseum is in the country of” locates the part of the "
                                                }
                                            ]
                                        }
                                    ]
                                },
                                {
                                    "key": "doc/body/sec0/sub2/txl2",
                                    "block_type": "txl",
                                    "children": [
                                        {
                                            "leaf id": 11,
                                            "key": "doc/body/sec0/sub2/txl2/txl0",
                                            "block type": "txl",
                                            "content": "A simple activation patching procedure typically looks like this:",
                                            "leftover": "",
                                            "matches": [
                                                {
                                                    "pdf_id": "1.2",
                                                    "matching_string": "A simple activation patching procedure typically looks like this:"
                                                }
                                            ]
                                        }
                                    ]
                                },
                                {
                                    "key": "doc/body/sec0/sub2/enumerate3",
                                    "block_type": "enumerate",
                                    "children": [
                                        {
                                            "key": "doc/body/sec0/sub2/enumerate3/txl0",
                                            "block_type": "txl",
                                            "children": [
                                                {
                                                    "leaf id": 12,
                                                    "key": "doc/body/sec0/sub2/enumerate3/txl0/txl0",
                                                    "block type": "txl",
                                                    "content": "Choose two similar prompts that differ in some key fact or otherwise elicit different model behaviour:",
                                                    "leftover": "",
                                                    "matches": [
                                                        {
                                                            "pdf_id": "1.3",
                                                            "matching_string": "Choose two similar prompts that differ in some key fact or otherwise elicit different model "
                                                        },
                                                        {
                                                            "pdf_id": "1.4",
                                                            "matching_string": "behaviour:"
                                                        }
                                                    ]
                                                }
                                            ]
                                        },
                                        {
                                            "leaf id": 13,
                                            "key": "doc/body/sec0/sub2/enumerate3/itemize1",
                                            "block type": "itemize",
                                            "content": "E.g. “The Colosseum is in” and “The Louvre is in” to vary the landmark but control for everything else.",
                                            "leftover": "",
                                            "matches": [
                                                {
                                                    "pdf_id": "1.7",
                                                    "matching_string": "for everything else."
                                                },
                                                {
                                                    "pdf_id": "1.5",
                                                    "matching_string": "E.g. “The Colosseum is in” and “The Louvre is in” to vary the landmark but control "
                                                }
                                            ]
                                        },
                                        {
                                            "leaf id": 14,
                                            "key": "doc/body/sec0/sub2/enumerate3/itemize2",
                                            "block type": "itemize",
                                            "content": "E.g. MLP outputs",
                                            "leftover": "",
                                            "matches": [
                                                {
                                                    "pdf_id": "1.8",
                                                    "matching_string": "E.g. MLP outputs"
                                                }
                                            ]
                                        },
                                        {
                                            "leaf id": 15,
                                            "key": "doc/body/sec0/sub2/enumerate3/itemize3",
                                            "block type": "itemize",
                                            "content": "E.g. “The Louvre is in” (source)",
                                            "leftover": "",
                                            "matches": [
                                                {
                                                    "pdf_id": "1.10",
                                                    "matching_string": "E.g. “The Louvre is in” (source)"
                                                }
                                            ]
                                        },
                                        {
                                            "leaf id": 16,
                                            "key": "doc/body/sec0/sub2/enumerate3/itemize4",
                                            "block type": "itemize",
                                            "content": "E.g. “The Colosseum is in” (destination)",
                                            "leftover": "",
                                            "matches": [
                                                {
                                                    "pdf_id": "1.13",
                                                    "matching_string": "E.g. “The Colosseum is in” (destination)"
                                                }
                                            ]
                                        },
                                        {
                                            "leaf id": 17,
                                            "key": "doc/body/sec0/sub2/enumerate3/itemize5",
                                            "block type": "itemize",
                                            "content": "E.g. observe change in the output logits for \"Paris\" and \"Rome\"",
                                            "leftover": "",
                                            "matches": [
                                                {
                                                    "pdf_id": "1.17",
                                                    "matching_string": "E.g. observe change in the output logits for \"Paris\" and \"Rome\""
                                                }
                                            ]
                                        },
                                        {
                                            "leaf id": 18,
                                            "key": "doc/body/sec0/sub2/enumerate3/itemize6",
                                            "block type": "itemize",
                                            "content": "E.g. sweep to test all MLP layers",
                                            "leftover": "",
                                            "matches": [
                                                {
                                                    "pdf_id": "1.19",
                                                    "matching_string": "E.g. sweep to test all MLP layers"
                                                }
                                            ]
                                        }
                                    ]
                                }
                            ]
                        },
                        {
                            "key": "doc/body/sec0/sub3",
                            "block_type": "sub",
                            "children": [
                                {
                                    "leaf id": 19,
                                    "key": "doc/body/sec0/sub3/tit",
                                    "block type": "title",
                                    "content": "What is this document about",
                                    "leftover": "",
                                    "matches": [
                                        {
                                            "pdf_id": "1.20",
                                            "matching_string": "What is this document about"
                                        }
                                    ]
                                },
                                {
                                    "key": "doc/body/sec0/sub3/txl0",
                                    "block_type": "txl",
                                    "children": [
                                        {
                                            "leaf id": 20,
                                            "key": "doc/body/sec0/sub3/txl0/txl0",
                                            "block type": "txl",
                                            "content": "We want to communicate useful practical advice for activation patching, and warn of common pitfalls to avoid. We focus on three areas in particular:",
                                            "leftover": "",
                                            "matches": [
                                                {
                                                    "pdf_id": "1.21",
                                                    "matching_string": "We want to communicate useful practical advice for activation patching, and warn of common pitfalls "
                                                },
                                                {
                                                    "pdf_id": "1.22",
                                                    "matching_string": "to avoid. We focus on three areas in particular:"
                                                }
                                            ]
                                        }
                                    ]
                                },
                                {
                                    "key": "doc/body/sec0/sub3/enumerate1",
                                    "block_type": "enumerate",
                                    "children": [
                                        {
                                            "leaf id": 21,
                                            "key": "doc/body/sec0/sub3/enumerate1/txl0",
                                            "block type": "txl",
                                            "content": "What kind of patching experiments provide which evidence? (Section ) How should you interpret activation patching results? (Section ) What metrics you can use, what are common pitfalls? (Section )",
                                            "leftover": ") ) )",
                                            "matches": [
                                                {
                                                    "pdf_id": "1.23",
                                                    "matching_string": "What kind of patching experiments provide which evidence? (Section "
                                                },
                                                {
                                                    "pdf_id": "1.24",
                                                    "matching_string": "How should you interpret activation patching results? (Section "
                                                },
                                                {
                                                    "pdf_id": "1.25",
                                                    "matching_string": "What metrics you can use, what are common pitfalls? (Section "
                                                }
                                            ]
                                        }
                                    ]
                                },
                                {
                                    "leaf id": 22,
                                    "key": "doc/body/sec0/sub3/txl2",
                                    "block type": "txl",
                                    "content": "For a general introduction to mechanistic interpretability in general, and activation patching in particular we refer to ARENAARENA: https://arena3chapter1transformerinterp.streamlit.app/ chapter 1 (in particular activation patching in chapter 1.3) as well as the corresponding glossary entries on Neel Nanda's websitehttps://neelnanda.io/glossary.",
                                    "leftover": "",
                                    "matches": [
                                        {
                                            "pdf_id": "1.40",
                                            "matching_string": "https://arena3chapter1transformerinterp.streamlit.app/ "
                                        },
                                        {
                                            "pdf_id": "1.27",
                                            "matching_string": "particular we refer to ARENAARENA: chapter 1 (in particular activation patching in chapter 1.3) as well as the corresponding glossary entries on Neel Nanda's "
                                        },
                                        {
                                            "pdf_id": "1.26",
                                            "matching_string": "For a general introduction to mechanistic interpretability in general, and activation patching in "
                                        },
                                        {
                                            "pdf_id": "1.41",
                                            "matching_string": "websitehttps://neelnanda.io/glossary."
                                        }
                                    ]
                                }
                            ]
                        }
                    ]
                },
                {
                    "key": "doc/body/sec1",
                    "block_type": "sec",
                    "children": [
                        {
                            "leaf id": 23,
                            "key": "doc/body/sec1/tit",
                            "block type": "title",
                            "content": "What kind of patching experiments should you run?",
                            "leftover": "",
                            "matches": [
                                {
                                    "pdf_id": "1.28",
                                    "matching_string": "What kind of patching experiments should you run?"
                                }
                            ]
                        },
                        {
                            "key": "doc/body/sec1/sub0",
                            "block_type": "sub",
                            "children": [
                                {
                                    "leaf id": 24,
                                    "key": "doc/body/sec1/sub0/tit",
                                    "block type": "title",
                                    "content": "Exploratory and confirmatory experiments",
                                    "leftover": "",
                                    "matches": [
                                        {
                                            "pdf_id": "1.29",
                                            "matching_string": "Exploratory and confirmatory experiments"
                                        }
                                    ]
                                },
                                {
                                    "key": "doc/body/sec1/sub0/txl0",
                                    "block_type": "txl",
                                    "children": [
                                        {
                                            "leaf id": 25,
                                            "key": "doc/body/sec1/sub0/txl0/txl0",
                                            "block type": "txl",
                                            "content": "In practice we tend to find ourselves in one of two different modes of operation: In exploratory mode we run experiments to find circuits and generate hypotheses. In confirmatory mode we want to verify the circuit we found and check if our hypothesis about its function is correct.",
                                            "leftover": "",
                                            "matches": [
                                                {
                                                    "pdf_id": "1.31",
                                                    "matching_string": "we run experiments to find circuits and generate hypotheses. In confirmatory mode we want to verify "
                                                },
                                                {
                                                    "pdf_id": "1.32",
                                                    "matching_string": "the circuit we found and check if our hypothesis about its function is correct."
                                                },
                                                {
                                                    "pdf_id": "1.30",
                                                    "matching_string": "In practice we tend to find ourselves in one of two different modes of operation: In exploratory mode "
                                                }
                                            ]
                                        }
                                    ]
                                },
                                {
                                    "key": "doc/body/sec1/sub0/txl1",
                                    "block_type": "txl",
                                    "children": [
                                        {
                                            "leaf id": 26,
                                            "key": "doc/body/sec1/sub0/txl1/txl0",
                                            "block type": "txl",
                                            "content": "In exploratory patching we typically patch components one at a time, often in a sweep over the model (layers, positions, model components). We do this to get an idea of which parts of a model are involved in the task in question, and may be part of the corresponding circuit.",
                                            "leftover": "",
                                            "matches": [
                                                {
                                                    "pdf_id": "1.33",
                                                    "matching_string": "In exploratory patching we typically patch components one at a time, often in a sweep over the "
                                                },
                                                {
                                                    "pdf_id": "1.34",
                                                    "matching_string": "model (layers, positions, model components). We do this to get an idea of which parts of a model are "
                                                },
                                                {
                                                    "pdf_id": "1.35",
                                                    "matching_string": "involved in the task in question, and may be part of the corresponding circuit."
                                                }
                                            ]
                                        }
                                    ]
                                },
                                {
                                    "leaf id": 27,
                                    "key": "doc/body/sec1/sub0/txl2",
                                    "block type": "txl",
                                    "content": "In confirmatory patching we want to confirm a hypothesised circuit by verifying that it actually covers all model components needed to perform the task in question. We typically do this by patching many model components at once and checking whether the task performance behaves as expected. A wellknown example of patching for circuit verification is Causal Scrubbing \\citep{causalscrubbing}.",
                                    "leftover": "",
                                    "matches": [
                                        {
                                            "pdf_id": "1.36",
                                            "matching_string": "In confirmatory patching we want to confirm a hypothesised circuit by verifying that it actually covers "
                                        },
                                        {
                                            "pdf_id": "1.37",
                                            "matching_string": "all model components needed to perform the task in question. We typically do this by patching "
                                        },
                                        {
                                            "pdf_id": "1.38",
                                            "matching_string": "many model components at once and checking whether the task performance behaves as expected. A "
                                        },
                                        {
                                            "pdf_id": "1.39",
                                            "matching_string": "wellknown example of patching for circuit verification is Causal Scrubbing \\citep{causalscrubbing}."
                                        }
                                    ]
                                }
                            ]
                        },
                        {
                            "key": "doc/body/sec1/sub1",
                            "block_type": "sub",
                            "children": [
                                {
                                    "leaf id": 28,
                                    "key": "doc/body/sec1/sub1/tit",
                                    "block type": "title",
                                    "content": "Which components should you patch",
                                    "leftover": "",
                                    "matches": [
                                        {
                                            "pdf_id": "2.0",
                                            "matching_string": "Which components should you patch"
                                        }
                                    ]
                                },
                                {
                                    "key": "doc/body/sec1/sub1/txl0",
                                    "block_type": "txl",
                                    "children": [
                                        {
                                            "leaf id": 29,
                                            "key": "doc/body/sec1/sub1/txl0/txl0",
                                            "block type": "txl",
                                            "content": "Patching can be done on different levels of granularity determining the components to patch. For example, we may patch the residual stream at a certain layer and position, or the output of a certain MLP [layer, position] or Attention Head [layer, head, position]. At even higher granularity we could patch individual neurons or sparse autoencoder features.",
                                            "leftover": "",
                                            "matches": [
                                                {
                                                    "pdf_id": "0.12",
                                                    "matching_string": ". "
                                                },
                                                {
                                                    "pdf_id": "2.1",
                                                    "matching_string": "Patching can be done on different levels of granularity determining the components to patch. For "
                                                },
                                                {
                                                    "pdf_id": "2.2",
                                                    "matching_string": "example, we may patch the residual stream at a certain layer and position, or the output of a certain "
                                                },
                                                {
                                                    "pdf_id": "2.3",
                                                    "matching_string": "MLP [layer, position] or Attention Head [layer, head, position]At even higher granularity we could "
                                                },
                                                {
                                                    "pdf_id": "2.4",
                                                    "matching_string": "patch individual neurons or sparse autoencoder features."
                                                }
                                            ]
                                        }
                                    ]
                                },
                                {
                                    "key": "doc/body/sec1/sub1/txl1",
                                    "block_type": "txl",
                                    "children": [
                                        {
                                            "leaf id": 30,
                                            "key": "doc/body/sec1/sub1/txl1/txl0",
                                            "block type": "txl",
                                            "content": "An even more specific type of patching is path patching. Usually, patching any component will affect all model components in later layers (“downstream”). In path patching instead we let each patch affect only a single target component. We call this patching the “path” between two components. For details on patch patching we refer to ARENA section 1.3.4.",
                                            "leftover": "",
                                            "matches": [
                                                {
                                                    "pdf_id": "2.5",
                                                    "matching_string": "An even more specific type of patching is path patching. Usually, patching any component will affect "
                                                },
                                                {
                                                    "pdf_id": "2.8",
                                                    "matching_string": "details on patch patching we refer to ARENA section 1.3.4."
                                                },
                                                {
                                                    "pdf_id": "2.6",
                                                    "matching_string": "all model components in later layers (“downstream”). In path patching instead we let each patch "
                                                },
                                                {
                                                    "pdf_id": "2.7",
                                                    "matching_string": "affect only a single target component. We call this patching the “path” between two components. For "
                                                }
                                            ]
                                        }
                                    ]
                                },
                                {
                                    "key": "doc/body/sec1/sub1/txl2",
                                    "block_type": "txl",
                                    "children": [
                                        {
                                            "leaf id": 31,
                                            "key": "doc/body/sec1/sub1/txl2/txl0",
                                            "block type": "txl",
                                            "content": "Path Patching can be used to understand whether circuit components affect each other directly, or via mediation by another component. For example if we want to distinguish between mediation (component A affects output C via component B), and amplification/calibration (component A affects output C directly, but component B reads from A and also affects output C by boosting or cancelling the signal to amplify or calibrate component A). These two structures look identical in default component patching, but different in path patching: a direct connection (composition) between A and C exists only in the second case.",
                                            "leftover": "",
                                            "matches": [
                                                {
                                                    "pdf_id": "2.9",
                                                    "matching_string": "Path Patching can be used to understand whether circuit components affect each other directly, or "
                                                },
                                                {
                                                    "pdf_id": "2.12",
                                                    "matching_string": "output C directly, but component B reads from A and also affects output C by boosting or cancelling "
                                                },
                                                {
                                                    "pdf_id": "2.13",
                                                    "matching_string": "the signal to amplify or calibrate component A). These two structures look identical in default "
                                                },
                                                {
                                                    "pdf_id": "2.14",
                                                    "matching_string": "component patching, but different in path patching: a direct connection (composition) between A and "
                                                },
                                                {
                                                    "pdf_id": "2.15",
                                                    "matching_string": "C exists only in the second case."
                                                },
                                                {
                                                    "pdf_id": "2.10",
                                                    "matching_string": "via mediation by another component. For example if we want to distinguish between mediation "
                                                },
                                                {
                                                    "pdf_id": "2.11",
                                                    "matching_string": "(component A affects output C via component B), and amplification/calibration (component A affects "
                                                }
                                            ]
                                        }
                                    ]
                                },
                                {
                                    "leaf id": 32,
                                    "key": "doc/body/sec1/sub1/txl3",
                                    "block type": "txl",
                                    "content": "As a rule of thumb, you want to start with lowgranularity patching (e.g. residual stream patching), then increase granularity, and finally use path patching to test which components interact with each other. Fast approximations to activation patching, such as attribution patching (see \\cite{attributionpatching}, and also AtP*, \\cite{atpstar}) can help speed up this process in large models.",
                                    "leftover": "",
                                    "matches": [
                                        {
                                            "pdf_id": "2.16",
                                            "matching_string": "As a rule of thumb, you want to start with lowgranularity patching (e.g. residual stream patching), "
                                        },
                                        {
                                            "pdf_id": "2.17",
                                            "matching_string": "then increase granularity, and finally use path patching to test which components interact with each "
                                        },
                                        {
                                            "pdf_id": "2.18",
                                            "matching_string": "other. Fast approximations to activation patching, such as attribution patching (see \\cite{attributionpatching}, and "
                                        },
                                        {
                                            "pdf_id": "2.19",
                                            "matching_string": "also AtP*, \\cite{atpstar}) can help speed up this process in large models."
                                        }
                                    ]
                                }
                            ]
                        },
                        {
                            "key": "doc/body/sec1/sub2",
                            "block_type": "sub",
                            "children": [
                                {
                                    "leaf id": 33,
                                    "key": "doc/body/sec1/sub2/tit",
                                    "block type": "title",
                                    "content": "Noising and Denoising",
                                    "leftover": "",
                                    "matches": [
                                        {
                                            "pdf_id": "2.20",
                                            "matching_string": "Noising and Denoising"
                                        }
                                    ]
                                },
                                {
                                    "key": "doc/body/sec1/sub2/txl0",
                                    "block_type": "txl",
                                    "children": [
                                        {
                                            "leaf id": 34,
                                            "key": "doc/body/sec1/sub2/txl0/txl0",
                                            "block type": "txl",
                                            "content": "There are multiple ways to do activation patching. The techniques differ in what the source (source of activations / model run from which the activations are copied) and destination prompt (destination that is overwritten / model run in which the activations will be inserted, this is called base in Interchange Interventions language, \\cite{2021arXiv211200826G}) are. The use of words “source” and “destination” is unrelated to their meaning in Transformer attention.",
                                            "leftover": "",
                                            "matches": [
                                                {
                                                    "pdf_id": "2.21",
                                                    "matching_string": "There are multiple ways to do activation patching. The techniques differ in what the source (source of "
                                                },
                                                {
                                                    "pdf_id": "2.22",
                                                    "matching_string": "activations / model run from which the activations are copied) and destination prompt (destination that "
                                                },
                                                {
                                                    "pdf_id": "2.23",
                                                    "matching_string": "is overwritten / model run in which the activations will be inserted, this is called base in Interchange "
                                                },
                                                {
                                                    "pdf_id": "2.25",
                                                    "matching_string": "unrelated to their meaning in Transformer attention."
                                                },
                                                {
                                                    "pdf_id": "2.24",
                                                    "matching_string": "Interventions language, \\cite{2021arXiv211200826G}) are. The use of words “source” and “destination” is "
                                                }
                                            ]
                                        }
                                    ]
                                },
                                {
                                    "key": "doc/body/sec1/sub2/txl1",
                                    "block_type": "txl",
                                    "children": [
                                        {
                                            "leaf id": 35,
                                            "key": "doc/body/sec1/sub2/txl1/txl0",
                                            "block type": "txl",
                                            "content": "The two main methods are Denoising and Noising (see the next section for other methods).",
                                            "leftover": "",
                                            "matches": [
                                                {
                                                    "pdf_id": "2.26",
                                                    "matching_string": "The two main methods are Denoising and Noising (see the next section for other methods)."
                                                }
                                            ]
                                        }
                                    ]
                                },
                                {
                                    "key": "doc/body/sec1/sub2/enumerate2",
                                    "block_type": "enumerate",
                                    "children": [
                                        {
                                            "leaf id": 36,
                                            "key": "doc/body/sec1/sub2/enumerate2/txl0",
                                            "block type": "txl",
                                            "content": "Denoising: We can patch activations from a clean first prompt into a corrupted second prompt “clean → corrupt”. That is running the model on the clean prompt while saving its activations, then running the model on the corrupted prompt while overwriting some of its activations with previously saved cleanprompt activations. We observe which patch restores the cleanprompt behaviour, i.e. patching which activations were sufficient to restore the behaviour. Noising: Or you can patch activations from a corrupted first prompt into a clean second prompt “corrupt → clean”. That is running the model on the corrupted prompt while saving its activations, then running the model on the clean prompt while overwriting some of its activations with previously saved corruptprompt activations. We observe which patch breaks the cleanprompt behaviour, i.e. patching which activations were necessary to maintain for the behaviour.",
                                            "leftover": "behaviour. ",
                                            "matches": [
                                                {
                                                    "pdf_id": "2.30",
                                                    "matching_string": "activations with previously saved cleanprompt activations. We observe which patch restores "
                                                },
                                                {
                                                    "pdf_id": "2.32",
                                                    "matching_string": "behaviour."
                                                },
                                                {
                                                    "pdf_id": "2.35",
                                                    "matching_string": "its activations, then running the model on the clean prompt while overwriting some of "
                                                },
                                                {
                                                    "pdf_id": "2.36",
                                                    "matching_string": "its activations with previously saved corruptprompt activations. We observe which patch "
                                                },
                                                {
                                                    "pdf_id": "2.37",
                                                    "matching_string": "breaks the cleanprompt behaviour, i.e. patching which activations were necessary to "
                                                },
                                                {
                                                    "pdf_id": "2.29",
                                                    "matching_string": "activations, then running the model on the corrupted prompt while overwriting some of its "
                                                },
                                                {
                                                    "pdf_id": "2.31",
                                                    "matching_string": "the cleanprompt behaviour, i.e. patching which activations were sufficient to restore the "
                                                },
                                                {
                                                    "pdf_id": "2.33",
                                                    "matching_string": "Noising: Or you can patch activations from a corrupted first prompt into a clean second "
                                                },
                                                {
                                                    "pdf_id": "2.38",
                                                    "matching_string": "maintain for the "
                                                },
                                                {
                                                    "pdf_id": "2.27",
                                                    "matching_string": "Denoising: We can patch activations from a clean first prompt into a corrupted second "
                                                },
                                                {
                                                    "pdf_id": "2.28",
                                                    "matching_string": "prompt “clean → corrupt”. That is running the model on the clean prompt while saving its "
                                                },
                                                {
                                                    "pdf_id": "2.34",
                                                    "matching_string": "prompt “corrupt → clean”. That is running the model on the corrupted prompt while saving "
                                                }
                                            ]
                                        }
                                    ]
                                },
                                {
                                    "key": "doc/body/sec1/sub2/txl3",
                                    "block_type": "txl",
                                    "children": [
                                        {
                                            "leaf id": 37,
                                            "key": "doc/body/sec1/sub2/txl3/txl0",
                                            "block type": "txl",
                                            "content": "An important and underrated point is that these two directions can be very different, and are not just symmetric mirrors of each other. In some situations denoising is the right tool, and in others it's noising, and understanding the differences is a crucial step in using patching correctly.",
                                            "leftover": "",
                                            "matches": [
                                                {
                                                    "pdf_id": "2.39",
                                                    "matching_string": "An important and underrated point is that these two directions can be very different, and are not just "
                                                },
                                                {
                                                    "pdf_id": "2.40",
                                                    "matching_string": "symmetric mirrors of each other. In some situations denoising is the right tool, and in others it's "
                                                },
                                                {
                                                    "pdf_id": "2.41",
                                                    "matching_string": "noising, and understanding the differences is a crucial step in using patching correctly."
                                                }
                                            ]
                                        }
                                    ]
                                },
                                {
                                    "key": "doc/body/sec1/sub2/adjustbox4",
                                    "block_type": "adjustbox",
                                    "children": [
                                        {
                                            "key": "doc/body/sec1/sub2/adjustbox4/txl0",
                                            "block_type": "txl",
                                            "children": [
                                                {
                                                    "leaf id": 38,
                                                    "key": "doc/body/sec1/sub2/adjustbox4/txl0/txl0",
                                                    "block type": "txl",
                                                    "content": "{width=1.2\\textwidth,center=\\textwidth}",
                                                    "leftover": "{width=1.2\\textwidth,center=\\textwidth}",
                                                    "matches": []
                                                }
                                            ]
                                        },
                                        {
                                            "key": "doc/body/sec1/sub2/adjustbox4/tabular1",
                                            "block_type": "tabular",
                                            "children": [
                                                {
                                                    "leaf id": 39,
                                                    "key": "doc/body/sec1/sub2/adjustbox4/tabular1/txl0",
                                                    "block type": "txl",
                                                    "content": "{p{3.6cm}p{2.5cm}lp{3.5cm}p{2.3cm}p{1.89cm}} \\toprule Technique & Source (saved) & Source run input & Destination / Base (overwritten) & Destination / Base run input & Observation \\midrule Clean → corrupted (Denoising, Causal Tracing\\footnotemark[2]) & First run activations (clean) & Clean tokens & Second run activations (corrupted) & Corrupt tokens & What restores behaviour Corrupted → clean (Noising, Resample Ablation) & First run activations (corrupted) & Corrupt tokens & Second run activations (clean) & Clean tokens & What breaks behaviour \\bottomrule",
                                                    "leftover": "",
                                                    "matches": [
                                                        {
                                                            "pdf_id": "2.44",
                                                            "matching_string": "Observation "
                                                        },
                                                        {
                                                            "pdf_id": "2.53",
                                                            "matching_string": "Corrupt tokens & What restores "
                                                        },
                                                        {
                                                            "pdf_id": "2.56",
                                                            "matching_string": "behaviour "
                                                        },
                                                        {
                                                            "pdf_id": "2.58",
                                                            "matching_string": "Corrupt tokens & Second run activations "
                                                        },
                                                        {
                                                            "pdf_id": "2.59",
                                                            "matching_string": "Clean tokens & What breaks "
                                                        },
                                                        {
                                                            "pdf_id": "2.61",
                                                            "matching_string": "(clean) "
                                                        },
                                                        {
                                                            "pdf_id": "2.62",
                                                            "matching_string": "behaviour "
                                                        },
                                                        {
                                                            "pdf_id": "4.9",
                                                            "matching_string": "First run activations "
                                                        },
                                                        {
                                                            "pdf_id": "4.10",
                                                            "matching_string": "Clean tokens & Second run activations "
                                                        },
                                                        {
                                                            "pdf_id": "4.15",
                                                            "matching_string": "First run activations "
                                                        },
                                                        {
                                                            "pdf_id": "2.43",
                                                            "matching_string": "Destination / "
                                                        },
                                                        {
                                                            "pdf_id": "2.46",
                                                            "matching_string": "Base run input "
                                                        },
                                                        {
                                                            "pdf_id": "2.47",
                                                            "matching_string": "Clean → corrupted (Denoising, "
                                                        },
                                                        {
                                                            "pdf_id": "2.49",
                                                            "matching_string": "Corrupted → clean (Noising, "
                                                        },
                                                        {
                                                            "pdf_id": "2.55",
                                                            "matching_string": "(corrupted) "
                                                        },
                                                        {
                                                            "pdf_id": "4.1",
                                                            "matching_string": "Destination / "
                                                        },
                                                        {
                                                            "pdf_id": "4.13",
                                                            "matching_string": "(corrupted) "
                                                        },
                                                        {
                                                            "pdf_id": "4.19",
                                                            "matching_string": "(clean) "
                                                        },
                                                        {
                                                            "pdf_id": "4.0",
                                                            "matching_string": "Technique & Source (saved) & Source run input & Base (o"
                                                        },
                                                        {
                                                            "pdf_id": "2.48",
                                                            "matching_string": "{p{3.6cm}p{2.5cm}lp{3.5cm}p{2.3cm}p{1.89cm}} \\toprule verwritten) & & \\midrule Causal Tracing\\footnotemark[2]) & & & Resample Ablation) & & & \\bottomrule"
                                                        },
                                                        {
                                                            "pdf_id": "4.12",
                                                            "matching_string": ""
                                                        },
                                                        {
                                                            "pdf_id": "4.16",
                                                            "matching_string": ""
                                                        },
                                                        {
                                                            "pdf_id": "4.18",
                                                            "matching_string": ""
                                                        }
                                                    ]
                                                }
                                            ]
                                        }
                                    ]
                                },
                                {
                                    "leaf id": 40,
                                    "key": "doc/body/sec1/sub2/txl5",
                                    "block type": "txl",
                                    "content": "For now we round patching effects to “if I patch these activations the model performance is / isn't affected”. We discuss metrics and measuring patching effects in the last section.",
                                    "leftover": "affected”. ",
                                    "matches": [
                                        {
                                            "pdf_id": "2.63",
                                            "matching_string": "For now we round patching effects to “if I patch these activations the model performance is / isn't "
                                        },
                                        {
                                            "pdf_id": "2.64",
                                            "matching_string": "We discuss metrics and measuring patching effects in the last section."
                                        }
                                    ]
                                }
                            ]
                        },
                        {
                            "key": "doc/body/sec1/sub3",
                            "block_type": "sub",
                            "children": [
                                {
                                    "leaf id": 41,
                                    "key": "doc/body/sec1/sub3/tit",
                                    "block type": "title",
                                    "content": "Example: AND gate vs OR gate",
                                    "leftover": "",
                                    "matches": [
                                        {
                                            "pdf_id": "3.0",
                                            "matching_string": "Example: AND gate vs OR gate"
                                        }
                                    ]
                                },
                                {
                                    "key": "doc/body/sec1/sub3/txl0",
                                    "block_type": "txl",
                                    "children": [
                                        {
                                            "leaf id": 42,
                                            "key": "doc/body/sec1/sub3/txl0/txl0",
                                            "block type": "txl",
                                            "content": "Consider a hypothetical circuit of three components A, B, and C that are connected with an AND or an OR gate. They are embedded in a much larger network, and of the three just C is connected to the output. We run an experiment where we patch all components using the denoising or noising technique.",
                                            "leftover": "",
                                            "matches": [
                                                {
                                                    "pdf_id": "3.1",
                                                    "matching_string": "Consider a hypothetical circuit of three components A, B, and C that are connected with an AND "
                                                },
                                                {
                                                    "pdf_id": "3.2",
                                                    "matching_string": "or an OR gate. They are embedded in a much larger network, and of the three just C is connected "
                                                },
                                                {
                                                    "pdf_id": "3.3",
                                                    "matching_string": "to the output. We run an experiment where we patch all components using the denoising or noising "
                                                },
                                                {
                                                    "pdf_id": "3.4",
                                                    "matching_string": "technique."
                                                }
                                            ]
                                        }
                                    ]
                                },
                                {
                                    "key": "doc/body/sec1/sub3/par1",
                                    "block_type": "par",
                                    "children": [
                                        {
                                            "key": "doc/body/sec1/sub3/par1/txl0",
                                            "block_type": "txl",
                                            "children": [
                                                {
                                                    "leaf id": 43,
                                                    "key": "doc/body/sec1/sub3/par1/txl0/txl0",
                                                    "block type": "txl",
                                                    "content": "AND circuit: C = A AND B",
                                                    "leftover": "",
                                                    "matches": [
                                                        {
                                                            "pdf_id": "3.5",
                                                            "matching_string": "AND circuit: C = A AND B"
                                                        }
                                                    ]
                                                }
                                            ]
                                        },
                                        {
                                            "key": "doc/body/sec1/sub3/par1/itemize1",
                                            "block_type": "itemize",
                                            "children": [
                                                {
                                                    "leaf id": 44,
                                                    "key": "doc/body/sec1/sub3/par1/itemize1/txl0",
                                                    "block type": "txl",
                                                    "content": "Denoising (clean → corrupt patching): Denoising either A or B has no effect on the output, only denoising C restores the output. This is because denoising A still leaves B at the corrupted (incorrect) baseline, and vice versa. Denoising found only one of the circuit components. Noising (corrupt → clean patching): Noising either A or B has an effect, as well as noising C.",
                                                    "leftover": "",
                                                    "matches": [
                                                        {
                                                            "pdf_id": "3.8",
                                                            "matching_string": "corrupted (incorrect) baseline, and vice versa. Denoising found only one of the circuit "
                                                        },
                                                        {
                                                            "pdf_id": "3.9",
                                                            "matching_string": "components. "
                                                        },
                                                        {
                                                            "pdf_id": "3.11",
                                                            "matching_string": "C."
                                                        },
                                                        {
                                                            "pdf_id": "3.6",
                                                            "matching_string": "Denoising (clean → corrupt patching): Denoising either A or B has no effect on the output, "
                                                        },
                                                        {
                                                            "pdf_id": "3.7",
                                                            "matching_string": "only denoising C restores the output. This is because denoising A still leaves B at the "
                                                        },
                                                        {
                                                            "pdf_id": "3.10",
                                                            "matching_string": "Noising (corrupt → clean patching): Noising either A or B has an effect, as well as noising "
                                                        }
                                                    ]
                                                }
                                            ]
                                        },
                                        {
                                            "leaf id": 45,
                                            "key": "doc/body/sec1/sub3/par1/txl2",
                                            "block type": "txl",
                                            "content": "Noising works better in this case, as it finds all circuit components in the first pass.",
                                            "leftover": "",
                                            "matches": [
                                                {
                                                    "pdf_id": "3.12",
                                                    "matching_string": "Noising works better in this case, as it finds all circuit components in the first pass."
                                                }
                                            ]
                                        }
                                    ]
                                },
                                {
                                    "key": "doc/body/sec1/sub3/par2",
                                    "block_type": "par",
                                    "children": [
                                        {
                                            "key": "doc/body/sec1/sub3/par2/txl0",
                                            "block_type": "txl",
                                            "children": [
                                                {
                                                    "leaf id": 46,
                                                    "key": "doc/body/sec1/sub3/par2/txl0/txl0",
                                                    "block type": "txl",
                                                    "content": "OR circuit: C = A OR B",
                                                    "leftover": "",
                                                    "matches": [
                                                        {
                                                            "pdf_id": "3.13",
                                                            "matching_string": "OR circuit: C = A OR B"
                                                        }
                                                    ]
                                                }
                                            ]
                                        },
                                        {
                                            "key": "doc/body/sec1/sub3/par2/itemize1",
                                            "block_type": "itemize",
                                            "children": [
                                                {
                                                    "leaf id": 47,
                                                    "key": "doc/body/sec1/sub3/par2/itemize1/txl0",
                                                    "block type": "txl",
                                                    "content": "Denoising (clean → corrupt patching): Denoising either A or B has an effect, as well as denoising C. Noising (corrupt → clean patching): Noising either A or B has no effect on the output, only denoising C restores the output. This is because noising A still leaves B at the clean (correct) baseline, and vice versa. Denoising found only one of the circuit components.",
                                                    "leftover": "",
                                                    "matches": [
                                                        {
                                                            "pdf_id": "3.14",
                                                            "matching_string": "Denoising (clean → corrupt patching): Denoising either A or B has an effect, as well as "
                                                        },
                                                        {
                                                            "pdf_id": "3.15",
                                                            "matching_string": "denoising C. "
                                                        },
                                                        {
                                                            "pdf_id": "3.18",
                                                            "matching_string": "baseline, and vice versa. Denoising found only one of the circuit components."
                                                        },
                                                        {
                                                            "pdf_id": "3.16",
                                                            "matching_string": "Noising (corrupt → clean patching): Noising either A or B has no effect on the output, only "
                                                        },
                                                        {
                                                            "pdf_id": "3.17",
                                                            "matching_string": "denoising C restores the output. This is because noising A still leaves B at the clean (correct) "
                                                        }
                                                    ]
                                                }
                                            ]
                                        },
                                        {
                                            "key": "doc/body/sec1/sub3/par2/txl2",
                                            "block_type": "txl",
                                            "children": [
                                                {
                                                    "leaf id": 48,
                                                    "key": "doc/body/sec1/sub3/par2/txl2/txl0",
                                                    "block type": "txl",
                                                    "content": "Denoising works better in this case, as it finds all circuit components in the first pass.",
                                                    "leftover": "",
                                                    "matches": [
                                                        {
                                                            "pdf_id": "3.19",
                                                            "matching_string": "Denoising works better in this case, as it finds all circuit components in the first pass."
                                                        }
                                                    ]
                                                }
                                            ]
                                        },
                                        {
                                            "leaf id": 49,
                                            "key": "doc/body/sec1/sub3/par2/txl3",
                                            "block type": "txl",
                                            "content": "These AND and OR structures can appear in realworld transformers as serialdependent components (e.g. a later attention head depending on an earlier one) or parallel components (such as redundant backup attention heads).",
                                            "leftover": "These AND ",
                                            "matches": [
                                                {
                                                    "pdf_id": "3.20",
                                                    "matching_string": "and OR structures can appear in realworld transformers as serialdependent components (e.g. a "
                                                },
                                                {
                                                    "pdf_id": "3.21",
                                                    "matching_string": "later attention head depending on an earlier one) or parallel components (such as redundant backup "
                                                },
                                                {
                                                    "pdf_id": "3.22",
                                                    "matching_string": "attention heads)."
                                                }
                                            ]
                                        }
                                    ]
                                }
                            ]
                        },
                        {
                            "key": "doc/body/sec1/sub4",
                            "block_type": "sub",
                            "children": [
                                {
                                    "leaf id": 50,
                                    "key": "doc/body/sec1/sub4/tit",
                                    "block type": "title",
                                    "content": "Comparison to ablations and other patching techniques",
                                    "leftover": "",
                                    "matches": [
                                        {
                                            "pdf_id": "3.23",
                                            "matching_string": "Comparison to ablations and other patching techniques"
                                        }
                                    ]
                                },
                                {
                                    "key": "doc/body/sec1/sub4/txl0",
                                    "block_type": "txl",
                                    "children": [
                                        {
                                            "leaf id": 51,
                                            "key": "doc/body/sec1/sub4/txl0/txl0",
                                            "block type": "txl",
                                            "content": "There are activation patching techniques based on a single prompt. The original Causal Tracing \\citep[ROME,][]ROME falls into this category, and also zero and meanablation can be seen as patching techniques.",
                                            "leftover": "",
                                            "matches": [
                                                {
                                                    "pdf_id": "3.26",
                                                    "matching_string": "patching techniques."
                                                },
                                                {
                                                    "pdf_id": "3.24",
                                                    "matching_string": "There are activation patching techniques based on a single prompt. The original Causal Tracing "
                                                },
                                                {
                                                    "pdf_id": "3.25",
                                                    "matching_string": "\\citep[ROME,][]ROME falls into this category, and also zero and meanablation can be seen as "
                                                }
                                            ]
                                        }
                                    ]
                                },
                                {
                                    "key": "doc/body/sec1/sub4/enumerate1",
                                    "block_type": "enumerate",
                                    "children": [
                                        {
                                            "leaf id": 52,
                                            "key": "doc/body/sec1/sub4/enumerate1/txl0",
                                            "block type": "txl",
                                            "content": "Zero ablation: Overwrite (“ablate”) the targeted activations with zeros and observe ablating which component breaks the model behaviour. Mean ablation: Same as above but overwrite targeted activations with their dataset mean value rather than zero. This is slightly more principled than zero ablating since there is no special meaning to activations being zero. Gaussian noise patching (also called Causal Tracing*): This is a clean → corrupt patching variant that uses as its corrupt run input the embeddings of the clean prompt with added Gaussian noise. The idea is to thereby automatically generate the corrupted “prompt”. It was originally used in ROME (called Causal Tracing there) but has not been used much recently, especially because the corruption can sometimes be ineffective.The success of Gaussian noise corruption is highly sensitive to the noise level. \\citet{Zhang2023} that if the noise level is just slightly lower than used in ROME, the model can recover the correct completion despite the corruption.",
                                            "leftover": "",
                                            "matches": [
                                                {
                                                    "pdf_id": "3.28",
                                                    "matching_string": "which component breaks the model behaviour. "
                                                },
                                                {
                                                    "pdf_id": "3.30",
                                                    "matching_string": "value rather than zero. This is slightly more principled than zero ablating since there is no "
                                                },
                                                {
                                                    "pdf_id": "3.31",
                                                    "matching_string": "special meaning to activations being zero. "
                                                },
                                                {
                                                    "pdf_id": "3.33",
                                                    "matching_string": "variant that uses as its corrupt run input the embeddings of the clean prompt with added "
                                                },
                                                {
                                                    "pdf_id": "3.35",
                                                    "matching_string": "was originally used in ROME (called Causal Tracing there) but has not been used much "
                                                },
                                                {
                                                    "pdf_id": "3.36",
                                                    "matching_string": "recently, especially because the corruption can sometimes be ineffective.T"
                                                },
                                                {
                                                    "pdf_id": "3.38",
                                                    "matching_string": "that if the noise level is just slightly lower than used in ROME, the model can recover the correct completion "
                                                },
                                                {
                                                    "pdf_id": "3.39",
                                                    "matching_string": "despite the corruption."
                                                },
                                                {
                                                    "pdf_id": "3.27",
                                                    "matching_string": "Zero ablation: Overwrite (“ablate”) the targeted activations with zeros and observe ablating "
                                                },
                                                {
                                                    "pdf_id": "3.29",
                                                    "matching_string": "Mean ablation: Same as above but overwrite targeted activations with their dataset mean "
                                                },
                                                {
                                                    "pdf_id": "3.32",
                                                    "matching_string": "Gaussian noise patching (also called Causal Tracing*): This is a clean → corrupt patching "
                                                },
                                                {
                                                    "pdf_id": "3.34",
                                                    "matching_string": "Gaussian noise. The idea is to thereby automatically generate the corrupted “prompt”. It "
                                                },
                                                {
                                                    "pdf_id": "3.37",
                                                    "matching_string": "he success of Gaussian noise corruption is highly sensitive to the noise level. \\citet{Zhang2023} "
                                                }
                                            ]
                                        }
                                    ]
                                },
                                {
                                    "key": "doc/body/sec1/sub4/adjustbox2",
                                    "block_type": "adjustbox",
                                    "children": [
                                        {
                                            "key": "doc/body/sec1/sub4/adjustbox2/txl0",
                                            "block_type": "txl",
                                            "children": [
                                                {
                                                    "leaf id": 53,
                                                    "key": "doc/body/sec1/sub4/adjustbox2/txl0/txl0",
                                                    "block type": "txl",
                                                    "content": "{width=1.2\\textwidth,center=\\textwidth} \\rowcolors{2}{white}{gray!25}",
                                                    "leftover": "{width=1.2\\textwidth,center=\\textwidth} \\rowcolors{2}{white}{gray!25}",
                                                    "matches": []
                                                }
                                            ]
                                        },
                                        {
                                            "key": "doc/body/sec1/sub4/adjustbox2/tabular1",
                                            "block_type": "tabular",
                                            "children": [
                                                {
                                                    "leaf id": 54,
                                                    "key": "doc/body/sec1/sub4/adjustbox2/tabular1/txl0",
                                                    "block type": "txl",
                                                    "content": "{p{3.6cm}p{2.5cm}lp{3.5cm}p{2.3cm}p{1.89cm}} \\toprule Technique & Source (saved) & Source run input & Destination / Base (overwritten) & Destination / Base run input & Observation \\midrule Clean → corrupted (Denoising, Causal Tracing\\footnotemark[2]) & First run activations (clean) & Clean tokens & Second run activations (corrupted) & Corrupt tokens & What restores behaviour Corrupted → clean (Noising, Resample Ablation) & First run activations (corrupted) & Corrupt tokens & Second run activations (clean) & Clean tokens & What breaks behaviour Zero ablation & Zero activations & N/A & Clean run activations & Clean tokens & What breaks behaviour Mean ablation & Dataset mean activations & N/A & Clean run activations & Clean tokens & What breaks behaviour Gaussian Noise patching (Causal Tracing\\footnotemark[2]) & First run activations (clean) & Clean tokens & Second run activations (corrupted from modified clean input) & Clean token embedding + Gaussian noise & What restores behaviour \\bottomrule",
                                                    "leftover": "",
                                                    "matches": [
                                                        {
                                                            "pdf_id": "2.52",
                                                            "matching_string": "Clean tokens & Second run activations "
                                                        },
                                                        {
                                                            "pdf_id": "2.57",
                                                            "matching_string": "First run activations "
                                                        },
                                                        {
                                                            "pdf_id": "2.60",
                                                            "matching_string": "(corrupted) "
                                                        },
                                                        {
                                                            "pdf_id": "4.2",
                                                            "matching_string": "Observation "
                                                        },
                                                        {
                                                            "pdf_id": "4.17",
                                                            "matching_string": "Clean tokens & What breaks "
                                                        },
                                                        {
                                                            "pdf_id": "4.25",
                                                            "matching_string": "Gaussian Noise patching "
                                                        },
                                                        {
                                                            "pdf_id": "4.31",
                                                            "matching_string": "(corrupted from modified "
                                                        },
                                                        {
                                                            "pdf_id": "4.32",
                                                            "matching_string": "clean input) "
                                                        },
                                                        {
                                                            "pdf_id": "4.33",
                                                            "matching_string": "Clean token embedding "
                                                        },
                                                        {
                                                            "pdf_id": "4.35",
                                                            "matching_string": "noise "
                                                        },
                                                        {
                                                            "pdf_id": "4.37",
                                                            "matching_string": "What restores "
                                                        },
                                                        {
                                                            "pdf_id": "2.50",
                                                            "matching_string": "Resample Ablation) "
                                                        },
                                                        {
                                                            "pdf_id": "4.4",
                                                            "matching_string": "Base run input "
                                                        },
                                                        {
                                                            "pdf_id": "4.5",
                                                            "matching_string": "Clean → corrupted (Denoising, "
                                                        },
                                                        {
                                                            "pdf_id": "4.7",
                                                            "matching_string": "Corrupted → clean (Noising, "
                                                        },
                                                        {
                                                            "pdf_id": "4.11",
                                                            "matching_string": "Corrupt tokens & What restores "
                                                        },
                                                        {
                                                            "pdf_id": "4.14",
                                                            "matching_string": "behaviour "
                                                        },
                                                        {
                                                            "pdf_id": "4.20",
                                                            "matching_string": "behaviour "
                                                        },
                                                        {
                                                            "pdf_id": "4.22",
                                                            "matching_string": "behaviour "
                                                        },
                                                        {
                                                            "pdf_id": "2.42",
                                                            "matching_string": "Technique & Source (saved) & Source run input & Destination / Base (o"
                                                        },
                                                        {
                                                            "pdf_id": "2.54",
                                                            "matching_string": "(clean) "
                                                        },
                                                        {
                                                            "pdf_id": "4.21",
                                                            "matching_string": "Zero ablation & Zero activations & N/A & Clean run activations & Clean tokens & What breaks "
                                                        },
                                                        {
                                                            "pdf_id": "4.23",
                                                            "matching_string": "Mean ablation & Dataset mean "
                                                        },
                                                        {
                                                            "pdf_id": "4.26",
                                                            "matching_string": "(Causal "
                                                        },
                                                        {
                                                            "pdf_id": "4.29",
                                                            "matching_string": "Clean tokens & Second run activations "
                                                        },
                                                        {
                                                            "pdf_id": "4.30",
                                                            "matching_string": "(clean) "
                                                        },
                                                        {
                                                            "pdf_id": "4.34",
                                                            "matching_string": "+ Gaussian "
                                                        },
                                                        {
                                                            "pdf_id": "4.36",
                                                            "matching_string": "behaviour "
                                                        },
                                                        {
                                                            "pdf_id": "4.38",
                                                            "matching_string": "behaviour "
                                                        },
                                                        {
                                                            "pdf_id": "2.51",
                                                            "matching_string": "{p{3.6cm}p{2.5cm}lp{3.5cm}p{2.3cm}p{1.89cm}} \\toprule verwritten) & Destination / & \\midrule Causal Tracing\\footnotemark[2]) & First run activations & (corrupted) & & First run activations & Corrupt tokens & Second run activations (clean) & Clean tokens & What breaks activations & N/A & Clean run activations & Tracing\\footnotemark[2]) & & & & \\bottomrule"
                                                        },
                                                        {
                                                            "pdf_id": "4.6",
                                                            "matching_string": ""
                                                        },
                                                        {
                                                            "pdf_id": "4.8",
                                                            "matching_string": ""
                                                        },
                                                        {
                                                            "pdf_id": "4.27",
                                                            "matching_string": ""
                                                        },
                                                        {
                                                            "pdf_id": "4.28",
                                                            "matching_string": ""
                                                        }
                                                    ]
                                                }
                                            ]
                                        }
                                    ]
                                },
                                {
                                    "leaf id": 55,
                                    "key": "doc/body/sec1/sub4/txl3",
                                    "block type": "txl",
                                    "content": "Generally we recommend corruptedpromptbased techniques, noising and denoising. Their advantage is that one can run very precise experiments, editing some features while controlling for others. They allow us to trace the difference between clean and corrupted prompt. To illustrate this consider the prompts “Angela Merkel is the leader of” → “Germany” vs “Joe Biden is the leader of” → “America”. Patching will find components that deal with Angela Merkel vs Joe Biden, but not components that would be indifferent to this change, such as the “answer is a country circuit” or the “political leader circuit”. A secondary advantage of noising and denoising is that they tend to bring the model less outofdistribution than ablation techniques (as pointed out in \\citet{causalscrubbing}, as well as in e.g. \\cite{2021arXiv210600786H})",
                                    "leftover": "",
                                    "matches": [
                                        {
                                            "pdf_id": "4.40",
                                            "matching_string": "is that one can run very precise experiments, editing some features while controlling for "
                                        },
                                        {
                                            "pdf_id": "4.41",
                                            "matching_string": "others. They allow us to trace the difference between clean and corrupted prompt. To illustrate this "
                                        },
                                        {
                                            "pdf_id": "4.43",
                                            "matching_string": "components that would be indifferent to this change, such as the “answer is a country circuit” or the "
                                        },
                                        {
                                            "pdf_id": "4.44",
                                            "matching_string": "political leader circuit”. A secondary advantage of noising and denoising is that they tend to bring "
                                        },
                                        {
                                            "pdf_id": "4.45",
                                            "matching_string": "the model less outofdistribution than ablation techniques (as pointed out in \\citet{causalscrubbing}, as "
                                        },
                                        {
                                            "pdf_id": "4.39",
                                            "matching_string": "Generally we recommend corruptedpromptbased techniques, noising and denoising. Their advantage "
                                        },
                                        {
                                            "pdf_id": "4.42",
                                            "matching_string": "consider the prompts “Angela Merkel is the leader of” → “Germany” vs “Joe Biden is the leader of” → “America”. Patching will find components that deal with Angela Merkel vs Joe Biden, but not "
                                        },
                                        {
                                            "pdf_id": "4.46",
                                            "matching_string": "“well as in e.g. \\cite{2021arXiv210600786H})"
                                        }
                                    ]
                                }
                            ]
                        },
                        {
                            "key": "doc/body/sec1/sub5",
                            "block_type": "sub",
                            "children": [
                                {
                                    "leaf id": 56,
                                    "key": "doc/body/sec1/sub5/tit",
                                    "block type": "title",
                                    "content": "Choosing corrupted prompts",
                                    "leftover": "",
                                    "matches": [
                                        {
                                            "pdf_id": "4.47",
                                            "matching_string": "Choosing corrupted prompts"
                                        }
                                    ]
                                },
                                {
                                    "key": "doc/body/sec1/sub5/txl0",
                                    "block_type": "txl",
                                    "children": [
                                        {
                                            "leaf id": 57,
                                            "key": "doc/body/sec1/sub5/txl0/txl0",
                                            "block type": "txl",
                                            "content": "Having a corrupted prompt is great because it can tell us what model components care about, but also a possible pitfall if we don't notice what our prompts trace and don't trace. We give some examples for the Indirect Object Identification \\citep[IOI,][]IOI demo sentence “John and Mary went to the store. John gave a bottle of milk to”. Different corruptions which highlight different properties the model might care about include:",
                                            "leftover": "",
                                            "matches": [
                                                {
                                                    "pdf_id": "4.48",
                                                    "matching_string": "Having a corrupted prompt is great because it can tell us what model components care about, but also "
                                                },
                                                {
                                                    "pdf_id": "4.49",
                                                    "matching_string": "a possible pitfall if we don't notice what our prompts trace and don't trace. We give some examples "
                                                },
                                                {
                                                    "pdf_id": "4.51",
                                                    "matching_string": "the store. John gave a bottle of milk to”. Different corruptions which highlight different properties "
                                                },
                                                {
                                                    "pdf_id": "4.52",
                                                    "matching_string": "the model might care about include:"
                                                },
                                                {
                                                    "pdf_id": "4.50",
                                                    "matching_string": "for the Indirect Object Identification \\citep[IOI,][]IOI demo sentence “John and Mary went to "
                                                }
                                            ]
                                        }
                                    ]
                                },
                                {
                                    "key": "doc/body/sec1/sub5/adjustbox1",
                                    "block_type": "adjustbox",
                                    "children": [
                                        {
                                            "key": "doc/body/sec1/sub5/adjustbox1/txl0",
                                            "block_type": "txl",
                                            "children": [
                                                {
                                                    "leaf id": 58,
                                                    "key": "doc/body/sec1/sub5/adjustbox1/txl0/txl0",
                                                    "block type": "txl",
                                                    "content": "{width=1\\textwidth,center=\\textwidth} \\rowcolors{2}{white}{gray!15}",
                                                    "leftover": "{width=1\\textwidth,center=\\textwidth} \\rowcolors{2}{white}{gray!15}",
                                                    "matches": []
                                                }
                                            ]
                                        },
                                        {
                                            "key": "doc/body/sec1/sub5/adjustbox1/tabular1",
                                            "block_type": "tabular",
                                            "children": [
                                                {
                                                    "leaf id": 59,
                                                    "key": "doc/body/sec1/sub5/adjustbox1/tabular1/txl0",
                                                    "block type": "txl",
                                                    "content": "{p{6.6cm}p{4cm}p{3.5cm}} \\toprule Corruption & Example & Property traced in model \\midrule None (Clean) & John and Mary … John … & Replace the value of one or multiple names, without changing the grammatical structure & John and Alice … John … Alice and Mary … Alice … Alice and Bob … Alice … & Where the model represents the name values Change which name is direct and indirect object without changing the names or positions & John and Mary … Mary … & The value and position of the indirect object Change the position of the names without changing which one is subject and indirect object & Mary and John … Mary … & The value, but not the position of the indirect object (position is fixed) Change a name to break the behaviour & John and Mary … Alice … Alice and Mary … John … & Specifics about IOI setting (e.g. that a name is duplicated at all) Change all the names & Alice and Bob … Charlie … & Finding and confirming all relevant components \\bottomrule",
                                                    "leftover": "{p{6.6cm}p{4cm}p{3.5cm}} \\toprule & \\midrule & … & & … … … & & & … … & … & \\bottomrule",
                                                    "matches": [
                                                        {
                                                            "pdf_id": "4.53",
                                                            "matching_string": "Corruption "
                                                        },
                                                        {
                                                            "pdf_id": "4.57",
                                                            "matching_string": "Replace the value of one or multiple names, "
                                                        },
                                                        {
                                                            "pdf_id": "4.59",
                                                            "matching_string": "Where the model represents "
                                                        },
                                                        {
                                                            "pdf_id": "4.60",
                                                            "matching_string": "without changing the grammatical structure "
                                                        },
                                                        {
                                                            "pdf_id": "4.67",
                                                            "matching_string": "Change the position of the names without changing "
                                                        },
                                                        {
                                                            "pdf_id": "4.71",
                                                            "matching_string": "of the indirect object "
                                                        },
                                                        {
                                                            "pdf_id": "4.74",
                                                            "matching_string": "Specifics about IOI setting "
                                                        },
                                                        {
                                                            "pdf_id": "4.76",
                                                            "matching_string": "Finding and confirming "
                                                        },
                                                        {
                                                            "pdf_id": "4.78",
                                                            "matching_string": "all relevant components "
                                                        },
                                                        {
                                                            "pdf_id": "4.55",
                                                            "matching_string": "Example & Property traced in model "
                                                        },
                                                        {
                                                            "pdf_id": "4.63",
                                                            "matching_string": "Change which name is direct and indirect object "
                                                        },
                                                        {
                                                            "pdf_id": "4.54",
                                                            "matching_string": "None (Clean) "
                                                        },
                                                        {
                                                            "pdf_id": "4.65",
                                                            "matching_string": "without changing the names or positions "
                                                        },
                                                        {
                                                            "pdf_id": "4.70",
                                                            "matching_string": "which one is subject and indirect object "
                                                        },
                                                        {
                                                            "pdf_id": "4.72",
                                                            "matching_string": "(position is fixed) "
                                                        },
                                                        {
                                                            "pdf_id": "4.80",
                                                            "matching_string": "(e.g. that a name is "
                                                        },
                                                        {
                                                            "pdf_id": "4.81",
                                                            "matching_string": "duplicated at all) "
                                                        },
                                                        {
                                                            "pdf_id": "4.66",
                                                            "matching_string": "the indirect object "
                                                        },
                                                        {
                                                            "pdf_id": "4.62",
                                                            "matching_string": "the name values "
                                                        },
                                                        {
                                                            "pdf_id": "4.68",
                                                            "matching_string": "Mary and John … Mary … & The value, but not the position "
                                                        },
                                                        {
                                                            "pdf_id": "4.73",
                                                            "matching_string": "Change a name to break the behaviour & John and Mary … Alice "
                                                        },
                                                        {
                                                            "pdf_id": "4.75",
                                                            "matching_string": "Change all the names & Alice and Bob … Charlie "
                                                        },
                                                        {
                                                            "pdf_id": "4.56",
                                                            "matching_string": "John and Mary … John "
                                                        },
                                                        {
                                                            "pdf_id": "4.58",
                                                            "matching_string": "John and Alice … John "
                                                        },
                                                        {
                                                            "pdf_id": "4.61",
                                                            "matching_string": "Alice and Mary … Alice "
                                                        },
                                                        {
                                                            "pdf_id": "4.64",
                                                            "matching_string": "John and Mary … Mary … & The value and position of "
                                                        },
                                                        {
                                                            "pdf_id": "4.69",
                                                            "matching_string": "Alice and Bob … Alice "
                                                        },
                                                        {
                                                            "pdf_id": "4.79",
                                                            "matching_string": "Alice and Mary … John "
                                                        }
                                                    ]
                                                }
                                            ]
                                        }
                                    ]
                                },
                                {
                                    "leaf id": 60,
                                    "key": "doc/body/sec1/sub5/txl2",
                                    "block type": "txl",
                                    "content": "What kind of prompt should you choose? No matter which you choose, keep in mind what properties your prompt does and does not change, and take this into account when interpreting patching results. As a rule of thumb you want to choose small (narrow) variations for exploratory patching, this will help you narrow down what each component is tracking. Choosing a narrow prompt distribution also helps increase the (typically low) sensitivity of denoising, and decrease the (typically high) sensitivity of noising. For confirmatory patching you need to choose a wide distribution of prompts that varies all variables of the hypothesised circuit. Then you can noise (corrupt → clean patch) all noncircuit components, and check that the model still shows the behaviour in question.",
                                    "leftover": "",
                                    "matches": [
                                        {
                                            "pdf_id": "4.82",
                                            "matching_string": "What kind of prompt should you choose? No matter which you choose, keep in mind what properties "
                                        },
                                        {
                                            "pdf_id": "4.83",
                                            "matching_string": "your prompt does and does not change, and take this into account when interpreting patching results. "
                                        },
                                        {
                                            "pdf_id": "4.84",
                                            "matching_string": "As a rule of thumb you want to choose small (narrow) variations for exploratory patching, this will "
                                        },
                                        {
                                            "pdf_id": "4.85",
                                            "matching_string": "help you narrow down what each component is tracking. Choosing a narrow prompt distribution also "
                                        },
                                        {
                                            "pdf_id": "4.86",
                                            "matching_string": "helps increase the (typically low) sensitivity of denoising, and decrease the (typically high) sensitivity "
                                        },
                                        {
                                            "pdf_id": "4.87",
                                            "matching_string": "of noising. For confirmatory patching you need to choose a wide distribution of prompts that varies "
                                        },
                                        {
                                            "pdf_id": "4.88",
                                            "matching_string": "all variables of the hypothesised circuit. Then you can noise (corrupt → clean patch) all noncircuit "
                                        },
                                        {
                                            "pdf_id": "4.89",
                                            "matching_string": "components, and check that the model still shows the behaviour in question."
                                        }
                                    ]
                                }
                            ]
                        }
                    ]
                },
                {
                    "key": "doc/body/sec2",
                    "block_type": "sec",
                    "children": [
                        {
                            "leaf id": 61,
                            "key": "doc/body/sec2/tit",
                            "block type": "title",
                            "content": "How do you interpret patching evidence?",
                            "leftover": "",
                            "matches": [
                                {
                                    "pdf_id": "5.0",
                                    "matching_string": "How do you interpret patching evidence?"
                                }
                            ]
                        },
                        {
                            "key": "doc/body/sec2/txl0",
                            "block_type": "txl",
                            "children": [
                                {
                                    "leaf id": 62,
                                    "key": "doc/body/sec2/txl0/txl0",
                                    "block type": "txl",
                                    "content": "In the previous section we said that denoising (clean → corrupt patching) tests whether the patched activations are sufficient to restore model behaviour. And noising (corrupt → clean patching) tests whether the patched activations are necessary to maintain model behaviour. These two are usually not complements of each other, nor does one imply the other. In this section we will walk through a madeup example experiment.",
                                    "leftover": "",
                                    "matches": [
                                        {
                                            "pdf_id": "5.1",
                                            "matching_string": "In the previous section we said that denoising (clean → corrupt patching) tests whether the patched activations are sufficient to restore model behaviour. And noising (corrupt → clean patching) tests "
                                        },
                                        {
                                            "pdf_id": "5.2",
                                            "matching_string": "whether the patched activations are necessary to maintain model behaviour. These two are usually "
                                        },
                                        {
                                            "pdf_id": "5.3",
                                            "matching_string": "not complements of each other, nor does one imply the other. In this section we will walk through a "
                                        },
                                        {
                                            "pdf_id": "5.4",
                                            "matching_string": "madeup example experiment."
                                        }
                                    ]
                                }
                            ]
                        },
                        {
                            "key": "doc/body/sec2/sub1",
                            "block_type": "sub",
                            "children": [
                                {
                                    "leaf id": 63,
                                    "key": "doc/body/sec2/sub1/tit",
                                    "block type": "title",
                                    "content": "Walkthrough a stylized example",
                                    "leftover": "",
                                    "matches": [
                                        {
                                            "pdf_id": "5.5",
                                            "matching_string": "Walkthrough a stylized example"
                                        }
                                    ]
                                },
                                {
                                    "key": "doc/body/sec2/sub1/txl0",
                                    "block_type": "txl",
                                    "children": [
                                        {
                                            "leaf id": 64,
                                            "key": "doc/body/sec2/sub1/txl0/txl0",
                                            "block type": "txl",
                                            "content": "Consider the hypothetical “Nobel Peace Prize” circuit. The model correctly completes “Nobel Peace” with “Prize”, using the following circuit:",
                                            "leftover": "Peace” ",
                                            "matches": [
                                                {
                                                    "pdf_id": "5.6",
                                                    "matching_string": "Consider the hypothetical “Nobel Peace Prize” circuit. The model correctly completes “Nobel "
                                                },
                                                {
                                                    "pdf_id": "5.7",
                                                    "matching_string": "with “Prize”, using the following circuit:"
                                                }
                                            ]
                                        }
                                    ]
                                },
                                {
                                    "key": "doc/body/sec2/sub1/itemize1",
                                    "block_type": "itemize",
                                    "children": [
                                        {
                                            "leaf id": 65,
                                            "key": "doc/body/sec2/sub1/itemize1/txl0",
                                            "block type": "txl",
                                            "content": "Attention head L0H0 is a “Previous Token Head” and copies the embedding of “Nobel” to the position of “Peace” Neuron L1N42 maps the mix of Nobel and Peace embeddings to the Prize logit Everything else doesn't matter (of course a real circuit is typically much messier)",
                                            "leftover": "“Peace” ",
                                            "matches": [
                                                {
                                                    "pdf_id": "5.10",
                                                    "matching_string": "Neuron L1N42 maps the mix of Nobel and Peace embeddings to the Prize logit "
                                                },
                                                {
                                                    "pdf_id": "5.11",
                                                    "matching_string": "Everything else doesn't matter (of course a real circuit is typically much messier)"
                                                },
                                                {
                                                    "pdf_id": "5.8",
                                                    "matching_string": "Attention head L0H0 is a “Previous Token Head” and copies the embedding of “Nobel” to "
                                                },
                                                {
                                                    "pdf_id": "5.9",
                                                    "matching_string": "the position of "
                                                }
                                            ]
                                        }
                                    ]
                                },
                                {
                                    "key": "doc/body/sec2/sub1/figure2",
                                    "block_type": "figure",
                                    "children": [
                                        {
                                            "leaf id": 66,
                                            "key": "doc/body/sec2/sub1/figure2/cpt0",
                                            "block type": "cpt",
                                            "content": "Toy \"Nobel Peace Price\" circuit",
                                            "leftover": "",
                                            "matches": [
                                                {
                                                    "pdf_id": "5.12",
                                                    "matching_string": "Toy \"Nobel Peace Price\" circuit"
                                                }
                                            ]
                                        }
                                    ]
                                },
                                {
                                    "key": "doc/body/sec2/sub1/txl3",
                                    "block_type": "txl",
                                    "children": [
                                        {
                                            "leaf id": 67,
                                            "key": "doc/body/sec2/sub1/txl3/txl0",
                                            "block type": "txl",
                                            "content": "Now let us run the standard patching examples, take a distribution of random English words for the corrupted prompt. We would find",
                                            "leftover": "",
                                            "matches": [
                                                {
                                                    "pdf_id": "5.13",
                                                    "matching_string": "Now let us run the standard patching examples, take a distribution of random English words for the "
                                                },
                                                {
                                                    "pdf_id": "5.14",
                                                    "matching_string": "corrupted prompt. We would find"
                                                }
                                            ]
                                        }
                                    ]
                                },
                                {
                                    "key": "doc/body/sec2/sub1/itemize4",
                                    "block_type": "itemize",
                                    "children": [
                                        {
                                            "leaf id": 68,
                                            "key": "doc/body/sec2/sub1/itemize4/txl0",
                                            "block type": "txl",
                                            "content": "Noising (corrupt → clean patching) suggests that the outputs of head L0H0, the output of neuron L1N42, and the embeddings (Nobel & Peace) are all necessary components. Denoising (clean → corrupt patching) suggests that the output of neuron L1N42 is sufficient to restore the circuit.",
                                            "leftover": "",
                                            "matches": [
                                                {
                                                    "pdf_id": "5.16",
                                                    "matching_string": "neuron L1N42, and the embeddings (Nobel & Peace) are all necessary components. "
                                                },
                                                {
                                                    "pdf_id": "5.18",
                                                    "matching_string": "to restore the circuit."
                                                },
                                                {
                                                    "pdf_id": "5.17",
                                                    "matching_string": "Denoising (clean → corrupt patching) suggests that the output of neuron L1N42 is sufficient "
                                                },
                                                {
                                                    "pdf_id": "5.15",
                                                    "matching_string": "Noising (corrupt → clean patching) suggests that the outputs of head L0H0, the output of "
                                                }
                                            ]
                                        }
                                    ]
                                },
                                {
                                    "key": "doc/body/sec2/sub1/txl5",
                                    "block_type": "txl",
                                    "children": [
                                        {
                                            "leaf id": 69,
                                            "key": "doc/body/sec2/sub1/txl5/txl0",
                                            "block type": "txl",
                                            "content": "What happened here? Denoising finds only the neuron output L1N42, because the other two components individually are not sufficient to restore the circuit behaviour! We're dealing with an AND circuit between the attention head output and the “Peace” embedding. Noising finds all three components here.",
                                            "leftover": "",
                                            "matches": [
                                                {
                                                    "pdf_id": "5.19",
                                                    "matching_string": "What happened here? Denoising finds only the neuron output L1N42, because the other two "
                                                },
                                                {
                                                    "pdf_id": "5.20",
                                                    "matching_string": "components individually are not sufficient to restore the circuit behaviour! We're dealing with an "
                                                },
                                                {
                                                    "pdf_id": "5.22",
                                                    "matching_string": "components here."
                                                },
                                                {
                                                    "pdf_id": "5.21",
                                                    "matching_string": "AND circuit between the attention head output and the “Peace” embedding. Noising finds all three "
                                                }
                                            ]
                                        }
                                    ]
                                },
                                {
                                    "key": "doc/body/sec2/sub1/txl6",
                                    "block_type": "txl",
                                    "children": [
                                        {
                                            "leaf id": 70,
                                            "key": "doc/body/sec2/sub1/txl6/txl0",
                                            "block type": "txl",
                                            "content": "Nonetheless denoising L1N42 alone restored the model behaviour. This is a crucial intuition to keep in mind about denoising: If you patch component A in layer N, it has seen clean versions of every component in layers 0 to N1. If there's an important component B in layer N1 that is mediated by component A, the model can be restored without denoising B.",
                                            "leftover": "",
                                            "matches": [
                                                {
                                                    "pdf_id": "5.23",
                                                    "matching_string": "Nonetheless denoising L1N42 alone restored the model behaviour. This is a crucial intuition to keep "
                                                },
                                                {
                                                    "pdf_id": "5.24",
                                                    "matching_string": "in mind about denoising: If you patch component A in layer N, it has seen clean versions of every "
                                                },
                                                {
                                                    "pdf_id": "5.25",
                                                    "matching_string": "component in layers 0 to N1. If there's an important component B in layer N1 that is mediated by "
                                                },
                                                {
                                                    "pdf_id": "5.26",
                                                    "matching_string": "component A, the model can be restored without denoising B."
                                                }
                                            ]
                                        }
                                    ]
                                },
                                {
                                    "key": "doc/body/sec2/sub1/txl7",
                                    "block_type": "txl",
                                    "children": [
                                        {
                                            "leaf id": 71,
                                            "key": "doc/body/sec2/sub1/txl7/txl0",
                                            "block type": "txl",
                                            "content": "Patching experiments are sensitive to what precisely are the changes between the corrupt and clean prompt. If we created two additional corrupt distributions where we replace only either “Nobel” or “Peace” with a random word (i.e. distributions “X Peace” and “Nobel Y”) we could narrow down which component depends on which input.",
                                            "leftover": "",
                                            "matches": [
                                                {
                                                    "pdf_id": "5.27",
                                                    "matching_string": "Patching experiments are sensitive to what precisely are the changes between the corrupt and clean "
                                                },
                                                {
                                                    "pdf_id": "5.30",
                                                    "matching_string": "which component depends on which input."
                                                },
                                                {
                                                    "pdf_id": "0.30",
                                                    "matching_string": "X "
                                                },
                                                {
                                                    "pdf_id": "0.32",
                                                    "matching_string": "a "
                                                },
                                                {
                                                    "pdf_id": "5.28",
                                                    "matching_string": "prompt. If we created two additional corrupt distributions where we replace only either “Nobel” or "
                                                },
                                                {
                                                    "pdf_id": "0.31",
                                                    "matching_string": "“Peace” with random word (i.e. distributions “Peace” and “Nobel Y”) we could narrow down "
                                                },
                                                {
                                                    "pdf_id": "5.29",
                                                    "matching_string": ""
                                                }
                                            ]
                                        }
                                    ]
                                },
                                {
                                    "leaf id": 72,
                                    "key": "doc/body/sec2/sub1/txl8",
                                    "block type": "txl",
                                    "content": "Alternatively we could use path patching to confirm the precise interactions. Say we want to test whether the Peace embedding is necessary as an input to L0H0, as an input to L1N42, or both. For this we could patch only the corresponding paths, and find that denoising (1) “Nobel → L0H0” and (2) “Peace → L1N42” paths is sufficient. Alternatively we might find that noising every path except for (1) “Nobel → L0H0”, (2) “L0 → L1N42”, and (3) “Peace → L1N42” does not break performance. Note again that denoising only required restoring two paths (restoring a crosssection of the circuit) while noising required leaving 3 paths clean (the full circuit).This method doesn't yet confirm which information is carried in the different paths. We can go a step further and noise (corrupt → clean patch) even some of the important circuit connections, namely “Nobel → L0H0 → L1N42” path from the “Nobel Y” distribution, and the “Peace → L1N42” path from the “X Peace” distribution. Doing that is essentially Causal Scrubbing \\citep{causalscrubbing}.",
                                    "leftover": "",
                                    "matches": [
                                        {
                                            "pdf_id": "6.0",
                                            "matching_string": "Alternatively we could use path patching to confirm the precise interactions. Say we want to test "
                                        },
                                        {
                                            "pdf_id": "6.1",
                                            "matching_string": "whether the Peace embedding is necessary as an input to L0H0, as an input to L1N42, or both. For "
                                        },
                                        {
                                            "pdf_id": "6.5",
                                            "matching_string": "Note again that denoising only required restoring two paths (restoring a crosssection of the circuit) "
                                        },
                                        {
                                            "pdf_id": "6.6",
                                            "matching_string": "while noising required leaving 3 paths clean (the full circuit).T"
                                        },
                                        {
                                            "pdf_id": "6.2",
                                            "matching_string": "this we could patch only the corresponding paths, and find that denoising (1) “Nobel → L0H0” and "
                                        },
                                        {
                                            "pdf_id": "6.3",
                                            "matching_string": "(2) “Peace → L1N42” paths is sufficient. Alternatively we might find that noising every path except "
                                        },
                                        {
                                            "pdf_id": "6.42",
                                            "matching_string": "method doesn't yet confirm which information is carried in the different paths. We can go a step further "
                                        },
                                        {
                                            "pdf_id": "6.43",
                                            "matching_string": "and noise (corrupt → clean patch) even some of the important circuit connections, namely “Nobel → L0H0 → "
                                        },
                                        {
                                            "pdf_id": "6.4",
                                            "matching_string": "for (1) “Nobel → L0H0”, (2) “L0 → L1N42”, and (3) “Peace → L1N42” does not break performance. "
                                        },
                                        {
                                            "pdf_id": "6.44",
                                            "matching_string": "path from the “Nobel Y” distribution, and the “Peace → L1N42” path from the “X Peace” distribution. "
                                        },
                                        {
                                            "pdf_id": "6.45",
                                            "matching_string": "his L1N42” Doing that is essentially Causal Scrubbing \\citep{causalscrubbing}."
                                        }
                                    ]
                                }
                            ]
                        },
                        {
                            "key": "doc/body/sec2/sub2",
                            "block_type": "sub",
                            "children": [
                                {
                                    "leaf id": 73,
                                    "key": "doc/body/sec2/sub2/tit",
                                    "block type": "title",
                                    "content": "Concepts & gotchas",
                                    "leftover": "",
                                    "matches": [
                                        {
                                            "pdf_id": "6.7",
                                            "matching_string": "Concepts & gotchas"
                                        }
                                    ]
                                },
                                {
                                    "key": "doc/body/sec2/sub2/txl0",
                                    "block_type": "txl",
                                    "children": [
                                        {
                                            "leaf id": 74,
                                            "key": "doc/body/sec2/sub2/txl0/txl0",
                                            "block type": "txl",
                                            "content": "The walkthrough above presents a typical circuit discovery workflow. We want to highlight a couple of additional concepts and common issues.",
                                            "leftover": "",
                                            "matches": [
                                                {
                                                    "pdf_id": "6.8",
                                                    "matching_string": "The walkthrough above presents a typical circuit discovery workflow. We want to highlight a couple "
                                                },
                                                {
                                                    "pdf_id": "6.9",
                                                    "matching_string": "of additional concepts and common issues."
                                                }
                                            ]
                                        }
                                    ]
                                },
                                {
                                    "key": "doc/body/sec2/sub2/par1",
                                    "block_type": "par",
                                    "children": [
                                        {
                                            "leaf id": 75,
                                            "key": "doc/body/sec2/sub2/par1/txl0",
                                            "block type": "txl",
                                            "content": "Sensitivity & prompt choice: A positive patching result implies you have found activations dealing with the difference between the clean and corrupt prompt. Make sure to consider all degrees of freedom in a task, and consider multiple sets of corrupted prompts if necessary.",
                                            "leftover": "",
                                            "matches": [
                                                {
                                                    "pdf_id": "6.10",
                                                    "matching_string": "Sensitivity & prompt choice: A positive patching result implies you have found activations dealing "
                                                },
                                                {
                                                    "pdf_id": "6.11",
                                                    "matching_string": "with the difference between the clean and corrupt prompt. Make sure to consider all degrees of "
                                                },
                                                {
                                                    "pdf_id": "6.12",
                                                    "matching_string": "freedom in a task, and consider multiple sets of corrupted prompts if necessary."
                                                }
                                            ]
                                        }
                                    ]
                                },
                                {
                                    "key": "doc/body/sec2/sub2/par2",
                                    "block_type": "par",
                                    "children": [
                                        {
                                            "leaf id": 76,
                                            "key": "doc/body/sec2/sub2/par2/txl0",
                                            "block type": "txl",
                                            "content": "Scope of activation patching: More generally, activation patching is always based on prompt distributions, and does not make statements for model behaviour outside these specific distributions. For more discussion on the limitations of patching, and the specificity of promptbased interpretability in general, see Neel Nanda's writing on What Can('t) Activation Patching Teach Us.",
                                            "leftover": "",
                                            "matches": [
                                                {
                                                    "pdf_id": "6.13",
                                                    "matching_string": "Scope of activation patching: More generally, activation patching is always based on prompt "
                                                },
                                                {
                                                    "pdf_id": "6.14",
                                                    "matching_string": "distributions, and does not make statements for model behaviour outside these specific distributions. "
                                                },
                                                {
                                                    "pdf_id": "6.15",
                                                    "matching_string": "For more discussion on the limitations of patching, and the specificity of promptbased interpretability "
                                                },
                                                {
                                                    "pdf_id": "6.16",
                                                    "matching_string": "in general, see Neel Nanda's writing on What Can('t) Activation Patching Teach Us."
                                                }
                                            ]
                                        }
                                    ]
                                },
                                {
                                    "key": "doc/body/sec2/sub2/par3",
                                    "block_type": "par",
                                    "children": [
                                        {
                                            "leaf id": 77,
                                            "key": "doc/body/sec2/sub2/par3/txl0",
                                            "block type": "txl",
                                            "content": "No minimality: Here, and in many parts of the literature, a circuit is treated as a collection of model components that are responsible for a particular model behaviour. We typically make no claims that we have found the smallest such collection of components, we only test that this collection is sufficient.",
                                            "leftover": "",
                                            "matches": [
                                                {
                                                    "pdf_id": "6.17",
                                                    "matching_string": "No minimality: Here, and in many parts of the literature, a circuit is treated as a collection of model "
                                                },
                                                {
                                                    "pdf_id": "6.18",
                                                    "matching_string": "components that are responsible for a particular model behaviour. We typically make no claims "
                                                },
                                                {
                                                    "pdf_id": "6.19",
                                                    "matching_string": "that we have found the smallest such collection of components, we only test that this collection is "
                                                },
                                                {
                                                    "pdf_id": "6.20",
                                                    "matching_string": "sufficient."
                                                }
                                            ]
                                        }
                                    ]
                                },
                                {
                                    "key": "doc/body/sec2/sub2/par4",
                                    "block_type": "par",
                                    "children": [
                                        {
                                            "key": "doc/body/sec2/sub2/par4/txl0",
                                            "block_type": "txl",
                                            "children": [
                                                {
                                                    "leaf id": 78,
                                                    "key": "doc/body/sec2/sub2/par4/txl0/txl0",
                                                    "block type": "txl",
                                                    "content": "Backup behaviour & ORgates: In some cases researchers have discovered “Backup heads”, components that are not normally doing the task but jump into action of other components are disrupted \\citep[Hydra effect,][]{2023arXiv230715771M}.",
                                                    "leftover": "",
                                                    "matches": [
                                                        {
                                                            "pdf_id": "6.22",
                                                            "matching_string": "components that are not normally doing the task but jump into action of other components are "
                                                        },
                                                        {
                                                            "pdf_id": "6.21",
                                                            "matching_string": "Backup behaviour & ORgates: In some cases researchers have discovered “Backup "
                                                        },
                                                        {
                                                            "pdf_id": "6.23",
                                                            "matching_string": "heads”, disrupted \\citep[Hydra effect,][]{2023arXiv230715771M}."
                                                        },
                                                        {
                                                            "pdf_id": "6.25",
                                                            "matching_string": ""
                                                        }
                                                    ]
                                                }
                                            ]
                                        },
                                        {
                                            "key": "doc/body/sec2/sub2/par4/txl1",
                                            "block_type": "txl",
                                            "children": [
                                                {
                                                    "leaf id": 79,
                                                    "key": "doc/body/sec2/sub2/par4/txl1/txl0",
                                                    "block type": "txl",
                                                    "content": "For example, in IOI when one ablates a name mover head (a key component of the circuit) a backup name mover head will activate and then do the task instead \\citepIOI.",
                                                    "leftover": "For example, in IOI when one ablates a name mover instead \\citepIOI.",
                                                    "matches": [
                                                        {
                                                            "pdf_id": "6.24",
                                                            "matching_string": "head (a key component of the circuit) a backup name mover head will activate and then do the task "
                                                        }
                                                    ]
                                                }
                                            ]
                                        },
                                        {
                                            "leaf id": 80,
                                            "key": "doc/body/sec2/sub2/par4/txl2",
                                            "block type": "txl",
                                            "content": "It can be helpful to think of these as ORgates where either component is sufficient for the model to work. This does not fit well into our attempts of defining a circuit, nor plays well with the circuit finding methods above. Despite the name mover heads being important, if we ablate them then, due to backup heads compensating, the name movers look less important. Fortunately, backup behaviour seems to be lossy, i.e. if the original component boosted the logits by +X, the backup compensates for this by boosting less than X (the Hydra effect paper found 0.7*X). Thus these backup component weaken the visibility of the original component, but it is usually still visible since even 0.3*X is a relatively large effect.",
                                            "leftover": "",
                                            "matches": [
                                                {
                                                    "pdf_id": "6.26",
                                                    "matching_string": "It can be helpful to think of these as ORgates where either component is sufficient for the model to "
                                                },
                                                {
                                                    "pdf_id": "6.27",
                                                    "matching_string": "work. This does not fit well into our attempts of defining a circuit, nor plays well with the circuit "
                                                },
                                                {
                                                    "pdf_id": "6.28",
                                                    "matching_string": "finding methods above. Despite the name mover heads being important, if we ablate them then, due "
                                                },
                                                {
                                                    "pdf_id": "6.29",
                                                    "matching_string": "to backup heads compensating, the name movers look less important. Fortunately, backup behaviour "
                                                },
                                                {
                                                    "pdf_id": "6.30",
                                                    "matching_string": "seems to be lossy, i.e. if the original component boosted the logits by +X, the backup compensates "
                                                },
                                                {
                                                    "pdf_id": "6.31",
                                                    "matching_string": "for this by boosting less than X (the Hydra effect paper found 0.7*X). Thus these backup component "
                                                },
                                                {
                                                    "pdf_id": "6.32",
                                                    "matching_string": "weaken the visibility of the original component, but it is usually still visible since even 0.3*X is a "
                                                },
                                                {
                                                    "pdf_id": "6.33",
                                                    "matching_string": "relatively large effect."
                                                }
                                            ]
                                        }
                                    ]
                                },
                                {
                                    "leaf id": 81,
                                    "key": "doc/body/sec2/sub2/par5",
                                    "block type": "par",
                                    "content": "Negative components: Some work in this area \\citep[e.g.][]{IOI,docstrings} noticed attention heads that consistently negatively affected performance, and noising them would increase performance. This is problematic, because it makes it hard to judge the quality of a circuit analysis: it may look like we've fully recovered (or more than fully recovered!) performance, by finding half the positive components but excluding all negative ones. This is an unsolved problem. \\citetACDC propose using Kullback Leibler (KL) divergence as a metric to address this, which penalises any deviation (positive or negative), at the cost of also tracking lots of variation we may not care about.",
                                    "leftover": "",
                                    "matches": [
                                        {
                                            "pdf_id": "6.36",
                                            "matching_string": "would increase performance. This is problematic, because it makes it hard to judge the quality of a "
                                        },
                                        {
                                            "pdf_id": "6.37",
                                            "matching_string": "circuit analysis: it may look like we've fully recovered (or more than fully recovered!) performance, "
                                        },
                                        {
                                            "pdf_id": "6.38",
                                            "matching_string": "by finding half the positive components but excluding all negative ones. This is an unsolved problem. "
                                        },
                                        {
                                            "pdf_id": "6.40",
                                            "matching_string": "which penalises any deviation (positive or negative), at the cost of also tracking lots of variation we "
                                        },
                                        {
                                            "pdf_id": "6.41",
                                            "matching_string": "may not care about."
                                        },
                                        {
                                            "pdf_id": "6.35",
                                            "matching_string": "noticed attention heads that consistently negatively affected performance, and noising them "
                                        },
                                        {
                                            "pdf_id": "11.15",
                                            "matching_string": "in this area \\citep[e.g.][]{IOI,docstrings} \\citetACDC propose using Kullback Leibler (KL) divergence as a "
                                        },
                                        {
                                            "pdf_id": "6.34",
                                            "matching_string": "Negative components: Some work metric to address this, "
                                        },
                                        {
                                            "pdf_id": "6.39",
                                            "matching_string": ""
                                        },
                                        {
                                            "pdf_id": "11.14",
                                            "matching_string": ""
                                        },
                                        {
                                            "pdf_id": "11.16",
                                            "matching_string": ""
                                        },
                                        {
                                            "pdf_id": "11.17",
                                            "matching_string": ""
                                        }
                                    ]
                                }
                            ]
                        }
                    ]
                },
                {
                    "key": "doc/body/sec3",
                    "block_type": "sec",
                    "children": [
                        {
                            "leaf id": 82,
                            "key": "doc/body/sec3/tit",
                            "block type": "title",
                            "content": "Metrics and common pitfalls",
                            "leftover": "",
                            "matches": [
                                {
                                    "pdf_id": "7.0",
                                    "matching_string": "Metrics and common pitfalls"
                                }
                            ]
                        },
                        {
                            "key": "doc/body/sec3/txl0",
                            "block_type": "txl",
                            "children": [
                                {
                                    "leaf id": 83,
                                    "key": "doc/body/sec3/txl0/txl0",
                                    "block type": "txl",
                                    "content": "So far we talked about “preserving” and “restoring” performance, but in practice, model performance is not binary but a scale. Typically we find some components matter a lot, while others provide a small increase in performance. For the best interpretability we might look for a circuit restoring e.g. 90% of the model's performance, rather than reaching exactly 100% \\citep[for examples see][]{causalscrubbing}. A useful framing is the “pareto frontier” of circuit size vs. performance recovered  recovering 80% of performance with 1% of the components is more impressive than 90% of the performance with 10% of the components, but there will always be a minimum circuit size to recover a given level of performance.",
                                    "leftover": "",
                                    "matches": [
                                        {
                                            "pdf_id": "7.2",
                                            "matching_string": "mponents matter a lot, while others provide a small increase in performance. For th"
                                        },
                                        {
                                            "pdf_id": "7.6",
                                            "matching_string": "80% of performance with 1% of the components is more impressive than 90% of the performance "
                                        },
                                        {
                                            "pdf_id": "7.7",
                                            "matching_string": "with 10% of the components, but there will always be a minimum circuit size to recover a given level "
                                        },
                                        {
                                            "pdf_id": "7.8",
                                            "matching_string": "of performance."
                                        },
                                        {
                                            "pdf_id": "7.1",
                                            "matching_string": " performance, but in practice, model performance is not binary but a scale. Typically we fi"
                                        },
                                        {
                                            "pdf_id": "9.13",
                                            "matching_string": "terpretability we might look for a circuit restoring e.g. 90% of the model's performanc"
                                        },
                                        {
                                            "pdf_id": "12.6",
                                            "matching_string": " coe best ine, rather than reaching exactly 100% \\citep[for examples see][]{causalscrubbing}. A useful frami"
                                        },
                                        {
                                            "pdf_id": "7.3",
                                            "matching_string": "So far we talked about “preserving” and “restoring”nd someng is the “pareto frontier” of circuit size vs. performance recovered  recovering "
                                        },
                                        {
                                            "pdf_id": "7.4",
                                            "matching_string": ""
                                        },
                                        {
                                            "pdf_id": "7.5",
                                            "matching_string": ""
                                        },
                                        {
                                            "pdf_id": "12.7",
                                            "matching_string": ""
                                        },
                                        {
                                            "pdf_id": "12.8",
                                            "matching_string": ""
                                        },
                                        {
                                            "pdf_id": "12.9",
                                            "matching_string": ""
                                        }
                                    ]
                                }
                            ]
                        },
                        {
                            "key": "doc/body/sec3/txl1",
                            "block_type": "txl",
                            "children": [
                                {
                                    "leaf id": 84,
                                    "key": "doc/body/sec3/txl1/txl0",
                                    "block type": "txl",
                                    "content": "It's easy to treat metrics as an afterthought, but we believe that the right or wrong choice of a metric can significantly change the interpretation of patching results. Especially for exploratory patching, the wrong metric can be misleading. The choice of metric matters less for confirmatory patching, where you expect a binaryish answer (“have I found the circuit or not”) and all metrics should agree. We'll go through a couple of metric choices in this section:",
                                    "leftover": "",
                                    "matches": [
                                        {
                                            "pdf_id": "7.11",
                                            "matching_string": "the wrong metric can be misleading. The choice of metric matters less for confirmatory patching, "
                                        },
                                        {
                                            "pdf_id": "7.13",
                                            "matching_string": "We'll go through a couple of metric choices in this section:"
                                        },
                                        {
                                            "pdf_id": "7.9",
                                            "matching_string": "It's easy to treat metrics as an afterthought, but we believe that the right or wrong choice of a metric "
                                        },
                                        {
                                            "pdf_id": "7.10",
                                            "matching_string": "can significantly change the interpretation of patching results. Especially for exploratory patching, "
                                        },
                                        {
                                            "pdf_id": "7.12",
                                            "matching_string": "where you expect a binaryish answer (“have I found the circuit or not”) and all metrics should agree. "
                                        }
                                    ]
                                }
                            ]
                        },
                        {
                            "key": "doc/body/sec3/table2",
                            "block_type": "table",
                            "children": [
                                {
                                    "key": "doc/body/sec3/table2/tabular0",
                                    "block_type": "tabular",
                                    "children": [
                                        {
                                            "leaf id": 85,
                                            "key": "doc/body/sec3/table2/tabular0/txl0",
                                            "block type": "txl",
                                            "content": "{ll} \\toprule Based on & Example \\midrule Logit difference (= Logprob difference) & Logit(Mary)  Logit(John) Logarithmic probability (logsoftmax) & Logprob(Mary) Probability (softmax) & Prob(Mary) Accuracy / Rank of correct answer & Rank(Mary)==0 \\bottomrule",
                                            "leftover": "{ll} \\toprule Based on & \\midrule Logit \\bottomrule",
                                            "matches": [
                                                {
                                                    "pdf_id": "7.14",
                                                    "matching_string": " Example"
                                                },
                                                {
                                                    "pdf_id": "7.16",
                                                    "matching_string": "difference (= Logprob difference) & Logit(Mary)  Logit(John) "
                                                },
                                                {
                                                    "pdf_id": "7.17",
                                                    "matching_string": "Logarithmic probability (logsoftmax) & Logprob(Mary) "
                                                },
                                                {
                                                    "pdf_id": "7.18",
                                                    "matching_string": "Probability (softmax) & Prob(Mary) "
                                                },
                                                {
                                                    "pdf_id": "7.19",
                                                    "matching_string": "Accuracy / Rank of correct answer & Rank(Mary)==0 "
                                                }
                                            ]
                                        }
                                    ]
                                }
                            ]
                        },
                        {
                            "key": "doc/body/sec3/txl3",
                            "block_type": "txl",
                            "children": [
                                {
                                    "leaf id": 86,
                                    "key": "doc/body/sec3/txl3/txl0",
                                    "block type": "txl",
                                    "content": "An honourable mention goes to the KL divergence. Unlike the previous metrics, this metric aims to compare the full model output, rather than focusing on a specific task. KL divergence is a good metric in such cases.",
                                    "leftover": "",
                                    "matches": [
                                        {
                                            "pdf_id": "7.20",
                                            "matching_string": "An honourable mention goes to the KL divergence. Unlike the previous metrics, this metric aims "
                                        },
                                        {
                                            "pdf_id": "7.21",
                                            "matching_string": "to compare the full model output, rather than focusing on a specific task. KL divergence is a good "
                                        },
                                        {
                                            "pdf_id": "7.22",
                                            "matching_string": "metric in such cases."
                                        }
                                    ]
                                }
                            ]
                        },
                        {
                            "key": "doc/body/sec3/txl4",
                            "block_type": "txl",
                            "children": [
                                {
                                    "leaf id": 87,
                                    "key": "doc/body/sec3/txl4/txl0",
                                    "block type": "txl",
                                    "content": "In addition to these output based metrics, in some cases it makes sense to consider some model internals as metrics themselves. For example, one might use the attention paid by the name mover head to the indirect object as a metric to identify the subcircuit controlling this head, or the activation of a key neuron or SAE feature, or the projection onto a probe \\citep{factfinding}.",
                                    "leftover": "",
                                    "matches": [
                                        {
                                            "pdf_id": "7.23",
                                            "matching_string": "In addition to these output based metrics, in some cases it makes sense to consider some model "
                                        },
                                        {
                                            "pdf_id": "7.24",
                                            "matching_string": "internals as metrics themselves. For example, one might use the attention paid by the name mover "
                                        },
                                        {
                                            "pdf_id": "7.25",
                                            "matching_string": "head to the indirect object as a metric to identify the subcircuit controlling this head, or the activation "
                                        },
                                        {
                                            "pdf_id": "9.29",
                                            "matching_string": "of a key neuron or SAE feature, or the "
                                        },
                                        {
                                            "pdf_id": "7.26",
                                            "matching_string": "projection onto a probe \\citep{factfinding}."
                                        },
                                        {
                                            "pdf_id": "9.26",
                                            "matching_string": ""
                                        },
                                        {
                                            "pdf_id": "9.27",
                                            "matching_string": ""
                                        },
                                        {
                                            "pdf_id": "9.28",
                                            "matching_string": ""
                                        },
                                        {
                                            "pdf_id": "9.30",
                                            "matching_string": ""
                                        },
                                        {
                                            "pdf_id": "9.31",
                                            "matching_string": ""
                                        },
                                        {
                                            "pdf_id": "9.32",
                                            "matching_string": ""
                                        }
                                    ]
                                }
                            ]
                        },
                        {
                            "key": "doc/body/sec3/txl5",
                            "block_type": "txl",
                            "children": [
                                {
                                    "leaf id": 88,
                                    "key": "doc/body/sec3/txl5/txl0",
                                    "block type": "txl",
                                    "content": "In our experience, it's worth implementing many metrics and briefly analysing all of them. Computing a metric is cheap (compared to the cost of the forward pass), and they all have different strengths and weaknesses, and can illuminate different parts of the big picture. And if they all agree that's stronger evidence than any metric on its own. Where they disagree, we personally trust logit difference (or equivalently logprob difference) the most.",
                                    "leftover": "",
                                    "matches": [
                                        {
                                            "pdf_id": "7.27",
                                            "matching_string": "In our experience, it's worth implementing many metrics and briefly analysing all of them. Computing "
                                        },
                                        {
                                            "pdf_id": "7.28",
                                            "matching_string": "a metric is cheap (compared to the cost of the forward pass), and they all have different strengths and "
                                        },
                                        {
                                            "pdf_id": "7.29",
                                            "matching_string": "weaknesses, and can illuminate different parts of the big picture. And if they all agree that's stronger "
                                        },
                                        {
                                            "pdf_id": "7.30",
                                            "matching_string": "evidence than any metric on its own. Where they disagree, we personally trust logit difference (or "
                                        },
                                        {
                                            "pdf_id": "7.31",
                                            "matching_string": "equivalently logprob difference) the most."
                                        }
                                    ]
                                }
                            ]
                        },
                        {
                            "key": "doc/body/sec3/sub6",
                            "block_type": "sub",
                            "children": [
                                {
                                    "leaf id": 89,
                                    "key": "doc/body/sec3/sub6/tit",
                                    "block type": "title",
                                    "content": "The logit difference",
                                    "leftover": "",
                                    "matches": [
                                        {
                                            "pdf_id": "7.32",
                                            "matching_string": "The logit difference"
                                        }
                                    ]
                                },
                                {
                                    "key": "doc/body/sec3/sub6/txl0",
                                    "block_type": "txl",
                                    "children": [
                                        {
                                            "leaf id": 90,
                                            "key": "doc/body/sec3/sub6/txl0/txl0",
                                            "block type": "txl",
                                            "content": "Logit difference measures to what extent the model knows the correct answer, and it allows us to be specific: We can control for things we don't want to measure (e.g. components that boost both, Mary and John, in the IOI example) by choosing the right logits to compare (e.g. Mary vs John, or multiplechoice answers). The metric also is a mostly linear function of the residual stream (unlike probabilitybased metrics) which makes it easy to directly attribute logit difference to individual components (“direct logit attribution”, “logit lens”). It's also a “softer” metric, allowing us to see partial effects on the model even if they don't change the rank of the output tokens (unlike e.g. accuracy), which is crucial for exploratory patching. We discuss problems with this and other metrics in the next section.",
                                            "leftover": "",
                                            "matches": [
                                                {
                                                    "pdf_id": "7.33",
                                                    "matching_string": "Logit difference measures to what extent the model knows the correct answer, and it allows us to "
                                                },
                                                {
                                                    "pdf_id": "7.34",
                                                    "matching_string": "be specific: We can control for things we don't want to measure (e.g. components that boost both, "
                                                },
                                                {
                                                    "pdf_id": "7.35",
                                                    "matching_string": "Mary and John, in the IOI example) by choosing the right logits to compare (e.g. Mary vs John, or "
                                                },
                                                {
                                                    "pdf_id": "7.36",
                                                    "matching_string": "multiplechoice answers). The metric also is a mostly linear function of the residual stream (unlike "
                                                },
                                                {
                                                    "pdf_id": "7.37",
                                                    "matching_string": "probabilitybased metrics) which makes it easy to directly attribute logit difference to individual "
                                                },
                                                {
                                                    "pdf_id": "7.39",
                                                    "matching_string": "partial effects on the model even if they don't change the rank of the output tokens (unlike e.g. "
                                                },
                                                {
                                                    "pdf_id": "7.40",
                                                    "matching_string": "accuracy), which is crucial for exploratory patching. We discuss problems with this and other metrics "
                                                },
                                                {
                                                    "pdf_id": "7.41",
                                                    "matching_string": "in the next section."
                                                },
                                                {
                                                    "pdf_id": "7.38",
                                                    "matching_string": "components (“direct logit attribution”, “logit lens”). It's also a “softer” metric, allowing us to see "
                                                }
                                            ]
                                        }
                                    ]
                                },
                                {
                                    "leaf id": 91,
                                    "key": "doc/body/sec3/sub6/txl1",
                                    "block type": "txl",
                                    "content": "Intuition for why logits and logit differences (LDs) are a natural unit for transformers: The residual stream and output of a transformer is a sum of components. Every component added to the residual stream corresponds to an addition to the LD (as the LD corresponds to a residual stream direction, up to layer norm). A model component can easily change the LD by some absolute amount (e.g. +1 LD). It cannot easily change the LD by a relative amount (LD *= 1.5), or change the probabilities by a specific amount (prob += 0.20). For example consider a model component that always outputs 1 logit to duplicated names (assume “John and Mary … John …”). This component then always writes +1 LD in favour of Mary, and gets a score of 1 in terms of LD. Other metrics (such as probability) judge this component differently, depending on what the baseline was (e.g. due to other patches). We would argue that logits and logit differences are closer to the mechanistic process happening in the transformer, and thus feel like a more natural unit. This is of course not a requirement, and also does not hold in all places (e.g. if a component's output depends on the input LD), but it seems to work well in practice.",
                                    "leftover": "",
                                    "matches": [
                                        {
                                            "pdf_id": "0.22",
                                            "matching_string": ". "
                                        },
                                        {
                                            "pdf_id": "7.44",
                                            "matching_string": "stream corresponds to an addition to the LD (as the LD corresponds to a residual stream direction, up "
                                        },
                                        {
                                            "pdf_id": "7.45",
                                            "matching_string": "to layer norm). A model component can easily change the LD by some absolute amount (e.g. +1 LD). "
                                        },
                                        {
                                            "pdf_id": "7.46",
                                            "matching_string": "It cannot easily change the LD by a relative amount (LD *= 1.5), or change the probabilities by a "
                                        },
                                        {
                                            "pdf_id": "7.49",
                                            "matching_string": "+1 LD in favour of Mary, and gets a score of 1 in terms of LD. Other metrics (such as probability) "
                                        },
                                        {
                                            "pdf_id": "7.50",
                                            "matching_string": "judge this component differently, depending on what the baseline was (e.g. due to other patches). We "
                                        },
                                        {
                                            "pdf_id": "8.0",
                                            "matching_string": "transformer, and thus feel like a more natural unit. This is of course not a requirement, and also does "
                                        },
                                        {
                                            "pdf_id": "8.1",
                                            "matching_string": "not hold in all places (e.g. if a component's output depends on the input LD), but it seems to work "
                                        },
                                        {
                                            "pdf_id": "8.2",
                                            "matching_string": "well in practice."
                                        },
                                        {
                                            "pdf_id": "7.42",
                                            "matching_string": "Intuition for why logits and logit differences (LDs) are a natural unit for transformers: The residual "
                                        },
                                        {
                                            "pdf_id": "7.43",
                                            "matching_string": "stream and output of a transformer is a sum of components. Every component added to the residual "
                                        },
                                        {
                                            "pdf_id": "7.51",
                                            "matching_string": "would argue that logits and logit differences are closer to the mechanistic process happening in the "
                                        },
                                        {
                                            "pdf_id": "7.47",
                                            "matching_string": "specific amount (prob += 0.20). For example consider a model component that always outputs 1 logit "
                                        },
                                        {
                                            "pdf_id": "7.48",
                                            "matching_string": "to duplicated names (assume “John and Mary … John …”)This component then always writes "
                                        }
                                    ]
                                }
                            ]
                        },
                        {
                            "key": "doc/body/sec3/sub7",
                            "block_type": "sub",
                            "children": [
                                {
                                    "leaf id": 92,
                                    "key": "doc/body/sec3/sub7/tit",
                                    "block type": "title",
                                    "content": "Flaws & advantages of different metrics",
                                    "leftover": "",
                                    "matches": [
                                        {
                                            "pdf_id": "8.3",
                                            "matching_string": "Flaws & advantages of different metrics"
                                        }
                                    ]
                                },
                                {
                                    "key": "doc/body/sec3/sub7/txl0",
                                    "block_type": "txl",
                                    "children": [
                                        {
                                            "leaf id": 93,
                                            "key": "doc/body/sec3/sub7/txl0/txl0",
                                            "block type": "txl",
                                            "content": "It is essential to be aware of what a metric measures and is sensitive to. A key thing to track is whether the metric is discrete vs continuous, and whether it's exponential vs linear (in the logits)  continuous, linear metrics are usually more accurate, which is crucial when doing exploratory patching and assigning “partial credit” to model components. Here we list common pitfalls of popular metrics.",
                                            "leftover": "the metric islinear ",
                                            "matches": [
                                                {
                                                    "pdf_id": "8.5",
                                                    "matching_string": " discrete vs continuous, and whether it's exponential vs linear (in the logits)  continuous, "
                                                },
                                                {
                                                    "pdf_id": "8.4",
                                                    "matching_string": "It is essential to be aware of what a metric measures and is sensitive to. A key thing to track is whether "
                                                },
                                                {
                                                    "pdf_id": "8.6",
                                                    "matching_string": "metrics are usually more accurate, which is crucial when doing exploratory patching and "
                                                },
                                                {
                                                    "pdf_id": "8.7",
                                                    "matching_string": "assigning “partial credit” to model components. Here we list common pitfalls of popular metrics."
                                                }
                                            ]
                                        }
                                    ]
                                },
                                {
                                    "key": "doc/body/sec3/sub7/figure1",
                                    "block_type": "figure",
                                    "children": [
                                        {
                                            "leaf id": 94,
                                            "key": "doc/body/sec3/sub7/figure1/cpt0",
                                            "block type": "cpt",
                                            "content": "Illustration of different metrics for an example patching experiment with GPT2 medium.",
                                            "leftover": "",
                                            "matches": [
                                                {
                                                    "pdf_id": "8.8",
                                                    "matching_string": "Illustration of different metrics for an example patching experiment with GPT2 medium."
                                                }
                                            ]
                                        }
                                    ]
                                },
                                {
                                    "key": "doc/body/sec3/sub7/itemize2",
                                    "block_type": "itemize",
                                    "children": [
                                        {
                                            "leaf id": 95,
                                            "key": "doc/body/sec3/sub7/itemize2/txl0",
                                            "block type": "txl",
                                            "content": "Logit difference / logprob difference: The difference between the logit of the correct answer, and the incorrect answer(s). This metric specifically measures the difference between the selected logits, and is not sensitive to components which affect all of them. For example, in IOI it measures the model's confidence in Mary vs John which encapsulates the IOIcircuit well without being sensitive to the “is the next token a name?”circuit. Potential falsepositive: Because the metric is a difference it may be driven by either getting better at the correct answer or worse at the incorrect answer. Thus it is worth checking the logits or logprobs of individual answers to confirm. This is particularly concerning because the corrupted model likely puts a high probability on the incorrect answer. This means that any patch that indiscriminately damages the model and gets it closer to uniform will damage the incorrect answer logprob and so boost the logit diff. Logprobs: This metric measures the logprob of the correct answer. It is sensitive to absolute change in logarithmic probabilities (i.e. relative change in probabilities) and captures our intuition for what good model performance means. We broadly think it is a good metric. It's main flaws are Saturation: Once the correct answer becomes the model's top guess, the logprob stops increasing meaningfully, even though the confidence can increase much more. We can see this in Figure, where the green line saturates after layer 17. Unspecificity: We lose the ability to control for other properties, e.g. in IOI we cannot distinguish between components that increase both P(John) and P(Mary) from components that only increase P(Mary). This can be intended, or unintended, it's just important to keep in mind. Inhibition: To increase the logprob on John, the model can either increase the John logit, or decrease other top logits, and it is hard to distinguish which is happening. This may be desirable or not because the two operations likely have different mechanisms and may be better tracked separately.",
                                            "leftover": "",
                                            "matches": [
                                                {
                                                    "pdf_id": "8.10",
                                                    "matching_string": "and the incorrect answer(s). This metric specifically measures the difference between the "
                                                },
                                                {
                                                    "pdf_id": "8.12",
                                                    "matching_string": "IOI it measures the model's confidence in Mary vs John which encapsulates the IOIcircuit "
                                                },
                                                {
                                                    "pdf_id": "8.15",
                                                    "matching_string": "better at the correct answer or worse at the incorrect answer. Thus it is worth checking the "
                                                },
                                                {
                                                    "pdf_id": "8.16",
                                                    "matching_string": "logits or logprobs of individual answers to confirm. "
                                                },
                                                {
                                                    "pdf_id": "8.17",
                                                    "matching_string": "This is particularly concerning because the corrupted model likely puts a high probability "
                                                },
                                                {
                                                    "pdf_id": "8.19",
                                                    "matching_string": "and gets it closer to uniform will damage the incorrect answer logprob and so boost the logit "
                                                },
                                                {
                                                    "pdf_id": "8.20",
                                                    "matching_string": "diff. "
                                                },
                                                {
                                                    "pdf_id": "8.22",
                                                    "matching_string": "change in logarithmic probabilities (i.e. relative change in probabilities) and captures our "
                                                },
                                                {
                                                    "pdf_id": "8.23",
                                                    "matching_string": "intuition for what good model performance means. We broadly think it is a good metric. It's "
                                                },
                                                {
                                                    "pdf_id": "8.24",
                                                    "matching_string": "main flaws are "
                                                },
                                                {
                                                    "pdf_id": "8.26",
                                                    "matching_string": "increasing meaningfully, even though the confidence can increase much more. "
                                                },
                                                {
                                                    "pdf_id": "8.29",
                                                    "matching_string": "cannot distinguish between components that increase both P(John) and P(Mary) from "
                                                },
                                                {
                                                    "pdf_id": "8.30",
                                                    "matching_string": "components that only increase P(Mary). This can be intended, or unintended, it's just "
                                                },
                                                {
                                                    "pdf_id": "8.31",
                                                    "matching_string": "important to keep in mind. "
                                                },
                                                {
                                                    "pdf_id": "8.33",
                                                    "matching_string": "logit, or decrease other top logits, and it is hard to distinguish which is happening. This "
                                                },
                                                {
                                                    "pdf_id": "9.0",
                                                    "matching_string": "may be desirable or not because the two operations likely have different mechanisms "
                                                },
                                                {
                                                    "pdf_id": "9.1",
                                                    "matching_string": "and may be better tracked separately."
                                                },
                                                {
                                                    "pdf_id": "8.18",
                                                    "matching_string": "on the incorrect answer. This means that any patch that indiscriminately damages the model "
                                                },
                                                {
                                                    "pdf_id": "8.9",
                                                    "matching_string": "Logit difference / logprob difference: The difference between the logit of the correct answer, "
                                                },
                                                {
                                                    "pdf_id": "8.13",
                                                    "matching_string": "well without being sensitive to the “is the next token a name?”circuit. "
                                                },
                                                {
                                                    "pdf_id": "8.14",
                                                    "matching_string": "Potential falsepositive: Because the metric is a difference it may be driven by either getting "
                                                },
                                                {
                                                    "pdf_id": "8.21",
                                                    "matching_string": "Logprobs: This metric measures the logprob of the correct answer. It is sensitive to absolute "
                                                },
                                                {
                                                    "pdf_id": "8.25",
                                                    "matching_string": "Saturation: Once the correct answer becomes the model's top guess, the logprob stops "
                                                },
                                                {
                                                    "pdf_id": "8.27",
                                                    "matching_string": "We can see this in Figure, where the green line saturates after layer 17. "
                                                },
                                                {
                                                    "pdf_id": "8.28",
                                                    "matching_string": "Unspecificity: We lose the ability to control for other properties, e.g. in IOI we "
                                                },
                                                {
                                                    "pdf_id": "8.32",
                                                    "matching_string": "Inhibition: To increase the logprob on John, the model can either increase the John "
                                                },
                                                {
                                                    "pdf_id": "8.11",
                                                    "matching_string": "selected logits, and is not sensitive to components which affect all of them. For example, in "
                                                }
                                            ]
                                        }
                                    ]
                                },
                                {
                                    "key": "doc/body/sec3/sub7/itemize3",
                                    "block_type": "itemize",
                                    "children": [
                                        {
                                            "leaf id": 96,
                                            "key": "doc/body/sec3/sub7/itemize3/txl0",
                                            "block type": "txl",
                                            "content": "Probabilities are nonlinear, in the sense that they track the logits ~exponentially. For example, a model component adding +2 to a given logit can create a 1 or 40 percentage point probability increase, just depending on what the baseline was. As an example of the nonlinearity consider the orange line in the figure above: A modest increase in logit difference around layer 17 converts to a jump in probability. Probabilities also inherit the problems of the logprob metric, namely saturation and unspecificity. The figure shows the saturation effect for the orange line at layer >18.",
                                            "leftover": "",
                                            "matches": [
                                                {
                                                    "pdf_id": "0.8",
                                                    "matching_string": "2 "
                                                },
                                                {
                                                    "pdf_id": "9.4",
                                                    "matching_string": "Probabilities are nonlinear, in the sense that they track the logits ~exponentially. For "
                                                },
                                                {
                                                    "pdf_id": "9.5",
                                                    "matching_string": "example, a model component adding +to a given logit can create a 1 or 40 percentage "
                                                },
                                                {
                                                    "pdf_id": "9.6",
                                                    "matching_string": "point probability increase, just depending on what the baseline was. "
                                                },
                                                {
                                                    "pdf_id": "9.7",
                                                    "matching_string": "As an example of the nonlinearity consider the orange line in the figure above: A "
                                                },
                                                {
                                                    "pdf_id": "9.8",
                                                    "matching_string": "modest increase in logit difference around layer 17 converts to a jump in probability. "
                                                },
                                                {
                                                    "pdf_id": "9.9",
                                                    "matching_string": "Probabilities also inherit the problems of the logprob metric, namely saturation and "
                                                },
                                                {
                                                    "pdf_id": "9.10",
                                                    "matching_string": "unspecificity. "
                                                },
                                                {
                                                    "pdf_id": "9.11",
                                                    "matching_string": "The figure shows the saturation effect for the orange line at layer >18."
                                                },
                                                {
                                                    "pdf_id": "0.4",
                                                    "matching_string": ""
                                                },
                                                {
                                                    "pdf_id": "0.5",
                                                    "matching_string": ""
                                                },
                                                {
                                                    "pdf_id": "0.6",
                                                    "matching_string": ""
                                                },
                                                {
                                                    "pdf_id": "0.7",
                                                    "matching_string": ""
                                                }
                                            ]
                                        }
                                    ]
                                },
                                {
                                    "key": "doc/body/sec3/sub7/itemize4",
                                    "block_type": "itemize",
                                    "children": [
                                        {
                                            "leaf id": 97,
                                            "key": "doc/body/sec3/sub7/itemize4/txl0",
                                            "block type": "txl",
                                            "content": "The problem with these is that generally many components contribute to a model's performance, with no single decisive contributor. Discrete metrics may suggest that some significant contributors are unimportant, because they aren't enough to cross a threshold. Alternatively, these metrics may suggest that one contributor among many is all that matters because it happens to be the one that pushes the model over the threshold. We generally recommend using continuous metrics instead. As an example consider the Figure above: The rankbased metric (red line) jumps around layer 15 when the corresponding logit passes the rank 1 and 0 thresholds, while it is not sensitive to any of the other changes. Discrete metrics can be a good fit for confirmatory patching rather than exploratory patching, as in some sense accuracy is the metric we care about  can the model get the question right or not?",
                                            "leftover": "",
                                            "matches": [
                                                {
                                                    "pdf_id": "9.14",
                                                    "matching_string": "decisive contributor. Discrete metrics may suggest that some significa"
                                                },
                                                {
                                                    "pdf_id": "9.17",
                                                    "matching_string": " many is all that matters because it happens to be the one that pushes the "
                                                },
                                                {
                                                    "pdf_id": "9.19",
                                                    "matching_string": "s instead. As an example consider the Figure above: The rankbase"
                                                },
                                                {
                                                    "pdf_id": "9.21",
                                                    "matching_string": "it passes the rank 1 and 0 thresholds, while it is not sensitive to any of "
                                                },
                                                {
                                                    "pdf_id": "9.24",
                                                    "matching_string": " as in some sense accuracy is the metric we care about  can the model get the "
                                                },
                                                {
                                                    "pdf_id": "9.25",
                                                    "matching_string": "question right or not?"
                                                },
                                                {
                                                    "pdf_id": "9.23",
                                                    "matching_string": "Discrete metrics can be a good fit for confirmatory patching rather than exploratory "
                                                },
                                                {
                                                    "pdf_id": "4.91",
                                                    "matching_string": "We generally recommend using continuous metricd metric (red line) jumps around layer 15 when the "
                                                },
                                                {
                                                    "pdf_id": "9.15",
                                                    "matching_string": "The problem with these is that generally many components contribute to a model's performance, with no single nt contributors are unimportant, because they aren't enough to cross a threshold. Alternatively, these metrics may suggest that one contributor amongmodel over the threshold. corresponding logthe other changes. patching,"
                                                },
                                                {
                                                    "pdf_id": "9.16",
                                                    "matching_string": ""
                                                },
                                                {
                                                    "pdf_id": "9.18",
                                                    "matching_string": ""
                                                },
                                                {
                                                    "pdf_id": "9.20",
                                                    "matching_string": ""
                                                },
                                                {
                                                    "pdf_id": "9.22",
                                                    "matching_string": ""
                                                }
                                            ]
                                        }
                                    ]
                                },
                                {
                                    "leaf id": 98,
                                    "key": "doc/body/sec3/sub7/figure5",
                                    "block type": "figure",
                                    "content": "\\centering \\includegraphics[width=0.9\\textwidth]{Screenshot.png}",
                                    "leftover": "\\centering \\includegraphics[width=0.9\\textwidth]{Screenshot.png}",
                                    "matches": []
                                }
                            ]
                        }
                    ]
                },
                {
                    "key": "doc/body/sec4",
                    "block_type": "sec",
                    "children": [
                        {
                            "leaf id": 99,
                            "key": "doc/body/sec4/tit",
                            "block type": "title",
                            "content": "Summary",
                            "leftover": "",
                            "matches": [
                                {
                                    "pdf_id": "10.0",
                                    "matching_string": "Summary"
                                }
                            ]
                        },
                        {
                            "key": "doc/body/sec4/txl0",
                            "block_type": "txl",
                            "children": [
                                {
                                    "leaf id": 100,
                                    "key": "doc/body/sec4/txl0/txl0",
                                    "block type": "txl",
                                    "content": "In most situations, use activation patching instead of ablations. Different corrupted prompts give you different information, be careful about what you choose and try to test a range of prompts.",
                                    "leftover": "",
                                    "matches": [
                                        {
                                            "pdf_id": "10.1",
                                            "matching_string": "In most situations, use activation patching instead of ablations. Different corrupted prompts give you "
                                        },
                                        {
                                            "pdf_id": "10.2",
                                            "matching_string": "different information, be careful about what you choose and try to test a range of prompts."
                                        }
                                    ]
                                }
                            ]
                        },
                        {
                            "key": "doc/body/sec4/txl1",
                            "block_type": "txl",
                            "children": [
                                {
                                    "leaf id": 101,
                                    "key": "doc/body/sec4/txl1/txl0",
                                    "block type": "txl",
                                    "content": "There are two different directions you can patch in: denoising and noising. These are not symmetric. Be aware of what a patching result implies!",
                                    "leftover": "",
                                    "matches": [
                                        {
                                            "pdf_id": "10.3",
                                            "matching_string": "There are two different directions you can patch in: denoising and noising. These are not symmetric. "
                                        },
                                        {
                                            "pdf_id": "10.4",
                                            "matching_string": "Be aware of what a patching result implies!"
                                        }
                                    ]
                                }
                            ]
                        },
                        {
                            "key": "doc/body/sec4/itemize2",
                            "block_type": "itemize",
                            "children": [
                                {
                                    "leaf id": 102,
                                    "key": "doc/body/sec4/itemize2/txl0",
                                    "block type": "txl",
                                    "content": "Denoising (a clean → corrupt patch) shows whether the patched activations were sufficient to restore the model behaviour. This implies the components make up a crosssection of the circuit. Noising (a corrupt → clean patch) shows whether the patched activations were necessary to maintain the model behaviour. This implies the components are part of the circuit.",
                                    "leftover": "circuit. ",
                                    "matches": [
                                        {
                                            "pdf_id": "10.5",
                                            "matching_string": "Denoising (a clean → corrupt patch) shows whether the patched activations were sufficient "
                                        },
                                        {
                                            "pdf_id": "10.7",
                                            "matching_string": "circuit."
                                        },
                                        {
                                            "pdf_id": "10.9",
                                            "matching_string": "maintain the model behaviour. This implies the components are part of the "
                                        },
                                        {
                                            "pdf_id": "10.6",
                                            "matching_string": "to restore the model behaviour. This implies the components make up a crosssection of the "
                                        },
                                        {
                                            "pdf_id": "10.8",
                                            "matching_string": "Noising (a corrupt → clean patch) shows whether the patched activations were necessary to "
                                        }
                                    ]
                                }
                            ]
                        },
                        {
                            "key": "doc/body/sec4/txl3",
                            "block_type": "txl",
                            "children": [
                                {
                                    "leaf id": 103,
                                    "key": "doc/body/sec4/txl3/txl0",
                                    "block type": "txl",
                                    "content": "Be careful when using metrics that are (i) discrete, (ii) overly sharp, or (iii) sensitive to unintended information. Ideally use a range of metrics, and try to have at least one metric that is continuous and roughly linear in logits such as logit difference or logprob. We recommend representing patching results in a big dataframe with a column per metric and row per patching experiment, and making a bunch of plots from this.",
                                    "leftover": "",
                                    "matches": [
                                        {
                                            "pdf_id": "10.10",
                                            "matching_string": "Be careful when using metrics that are (i) discrete, (ii) overly sharp, or (iii) sensitive to unintended "
                                        },
                                        {
                                            "pdf_id": "10.11",
                                            "matching_string": "information. Ideally use a range of metrics, and try to have at least one metric that is continuous and "
                                        },
                                        {
                                            "pdf_id": "10.12",
                                            "matching_string": "roughly linear in logits such as logit difference or logprob. We recommend representing patching "
                                        },
                                        {
                                            "pdf_id": "10.13",
                                            "matching_string": "results in a big dataframe with a column per metric and row per patching experiment, and making a "
                                        },
                                        {
                                            "pdf_id": "10.14",
                                            "matching_string": "bunch of plots from this."
                                        }
                                    ]
                                }
                            ]
                        },
                        {
                            "key": "doc/body/sec4/itemize4",
                            "block_type": "itemize",
                            "children": [
                                {
                                    "leaf id": 104,
                                    "key": "doc/body/sec4/itemize4/txl0",
                                    "block type": "txl",
                                    "content": "Model topk accuracy is discrete and can overrepresent changes at thresholds and shows no change for large effects that don't cross thresholds. Most effects from patching are linear and additive in logit space. Probability is exponential in logit space, so it overemphasises effects near a threshold and suppresses effects elsewhere, creating overly sharp patching plots Logprob can saturate, and cannot control for a patch that boosts both the correct and incorrect answer(s)",
                                    "leftover": "",
                                    "matches": [
                                        {
                                            "pdf_id": "10.15",
                                            "matching_string": "Model topk accuracy is discrete and can overrepresent changes at thresholds and shows no "
                                        },
                                        {
                                            "pdf_id": "10.16",
                                            "matching_string": "change for large effects that don't cross thresholds. "
                                        },
                                        {
                                            "pdf_id": "10.17",
                                            "matching_string": "Most effects from patching are linear and additive in logit space. Probability is exponential "
                                        },
                                        {
                                            "pdf_id": "10.18",
                                            "matching_string": "in logit space, so it overemphasises effects near a threshold and suppresses effects elsewhere, "
                                        },
                                        {
                                            "pdf_id": "10.19",
                                            "matching_string": "creating overly sharp patching plots "
                                        },
                                        {
                                            "pdf_id": "10.20",
                                            "matching_string": "Logprob can saturate, and cannot control for a patch that boosts both the correct and incorrect "
                                        },
                                        {
                                            "pdf_id": "10.21",
                                            "matching_string": "answer(s)"
                                        }
                                    ]
                                }
                            ]
                        }
                    ]
                },
                {
                    "key": "doc/body/sec5",
                    "block_type": "sec",
                    "children": [
                        {
                            "leaf id": 105,
                            "key": "doc/body/sec5/tit",
                            "block type": "title",
                            "content": "Acknowledgements",
                            "leftover": "",
                            "matches": [
                                {
                                    "pdf_id": "10.22",
                                    "matching_string": "Acknowledgements"
                                }
                            ]
                        },
                        {
                            "leaf id": 106,
                            "key": "doc/body/sec5/txl0",
                            "block type": "txl",
                            "content": "Thanks to Arthur Conmy, Chris Mathwin, James Lucassen, and Fred Zhang for comments on a draft of this manuscript. \\printbibliography",
                            "leftover": "\\printbibliography",
                            "matches": [
                                {
                                    "pdf_id": "10.23",
                                    "matching_string": "Thanks to Arthur Conmy, Chris Mathwin, James Lucassen, and Fred Zhang for comments on a draft "
                                },
                                {
                                    "pdf_id": "10.24",
                                    "matching_string": "of this manuscript. "
                                }
                            ]
                        }
                    ]
                }
            ]
        }
    ]
}